---
layout: post
title: Analyzing MacOS Malware that Executes a Payload in Memory
excerpt: This post was inspired by a Twitter post about a piece of MacOS malware created by the Lazarus Group. This malware has a special ability, it can load a Mach-O into memory and then execute it without it ever touching the disk.

---

This post was inspired by Dinesh Devadoss's [post on twitter](https://twitter.com/dineshdina04/status/1201834142704394242?s=20) about a piece of MacOS malware from the Lazarus group that loads a Mach-O into memory and executes it.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_1.png)

Loading a Mach-O into memory for execution peeked my interest and I wanted to know how it worked. So I obtained a sample of the malware from the website spreading it. The malware was obtained from `https://unioncrypto.vip/` , which is now down but previously resolved to `104.168.167.16`.

I first searched the MD5 hash of the file (`6588d262529dc372c400bef8478c2eec`) on VirusTotal. It had been uploaded and most of the major AV companies flag the malware. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_2.png)

Using VirusTotal, we can get a lot of preliminary information about the malware. Some interesting information is files opened, written, and dropped. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_3.png)

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_4.png)

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_5.png)

To inspect the file locally, first I mounted the disk image with `hdiutil attach UnionCryptoTrader.dmg`. It contained a single file named `UnionCryptoTrader.pkg`.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_6.png)

The package file was not singed, meaning MacOS would prompt the user with a warning before they could install the package.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_7.png)

Examine the package file, I extracted the app installed, `UnionCryptoTrader.app` and any scripts within the package with resulted in a `postinstall` script.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_8.png)

Before I jumped into the app executable, I wanted to see what the `postinstall` script did.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_9.png)

In line 2, script moves a hidden plist file (`.vip.unioncrypto.plist`) from the app's resources to the Launch Daemons directory, probably to give the app persistence across reboots or when a user logs out. The script then sets the plist to be owned by root in line 4. Since it does this, the user will also have to enter the root password to install this on their machine, hopefully adding some doubt to unsuspecting users. Line 6 creates a directory, and line 8 moves a hidden executable (`.unioncryptoupdater`) from the resources into the Library path. Line 10 sets executable permissions and line 12 executes the binary. Once this script runs successfully, `unioncryptoupdater` is running and is persistently installed to the machine.

Going to the app's package contents, then using Command + Shift + . in finder, I could easily see the hidden files. Opening up the plist file shows `RunAtLoad` set to true, further confirming persistence.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_10.png)

The file is a standard Mach-O 64 bit binary with ad-hoc code signing.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_11.png)

Next, I looked at the strings in the binary.


```
curl_easy_perform() failed: %s
Response <
> thrown.
AES_CYPHER_128 encrypt test case:
AES_CYPHER_128 decrypt test case:
AES_CYPHER_192 encrypt test case:
AES_CYPHER_192 decrypt test case:
AES_CYPHER_256 encrypt test case:
AES_CYPHER_256 decrypt test case:
Input:
IOPlatformExpertDevice
IOPlatformSerialNumber
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
ProductBuildVersion
Mac OS X %s (%s)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
/tmp/updater
%s %s
NO_ID
%s%s
12GWAPCT1F0I1S14
auth_timestamp
auth_signature
check
https://unioncrypto.vip/update
done
/bin/rcp
Could not create image.
core
Could not link image.
Could not find ec.
Could not resolve symbol: _sym[25] == 0x4d6d6f72.
Could not resolve symbol: _sym[4] == 0x4d6b6e69.
c|w{
9JLX
~=d]
lpHP
cU!}
"3DUfw
0123456789abcdef
dictionaryWithContentsOfFile:
objectForKey:
UTF8String
```

The first thing I noted was `curl_easy_perform() failed: %s`. The binary includes `libcurl` so it probably has some network functionality. Other things to note are` IOPlatformExpertDevice`, `IOPlatformSerialNumber`, `/System/Library/CoreServices/SystemVersion.plist`, `ProductVersion`, and `ProductBuildVersion`. The malware appears to gather a lot of system information.

I then decided it was time to open the binary in a disassembler. The binary begins with the expected Mach-O signature `FE ED FA CF`. It does some setup stuff, then proceeds to a function appropriately named `onRun`. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_12.png)

The function proceeds to setup a class named `Barbeque`. It contains functions such as `Barbeque::get`, `Barbeque::post`, and includes references to `libcurl`, so it's safe to assume this is the networking class for the malware. The function then calls another function named `getDeviceSerial` at `0x1000051f2`. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_13.png)

This code initializes IOKit, calls `IORegistryEntryCreateCFProperty` with the `IOPlatformSerialNumber` key, converts it to C string buffer with `CFStringGetCString`, and returns the serial number. The `onRun` function continues and calls a function named `getOSVersion` at `0x10000522a`.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_14.png)

This code reads the file `/System/Library/CoreServices/SystemVersion.plist` and reads the `ProductName`, `ProductUserVisibleVersion`, and `ProductBuildVersion` keys from the plist file and begins to build a string. Later in `onRun`, the current time is added to the string and the hardcoded values `\x31\x32\x47\x57\x41\x50\x43\x54\x31\x46\x30\x49\x31\x53\x31\x34` are appended to it. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_15.png)

Next the malware invokes `Barbeque:post` which uses `libcurl` to send the string to `https://unioncrypto.vip/update`. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_16.png)

The malware then awaits a response. If the response is `0` the function jumps to `0x10000583f` which is a short function that calls `sleep()` for 10 minutes. However, if the server doesn't return `0`, it base64 decodes the response and calls `processUpdate()` as seen in the following disassembly. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_17.png)

And this is the first part of `processUpdate()`:

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_18.png)

There are some checks to make sure the string is valid and then the string is AES decrypted as seen at the function call at `0x100004c85`. The malware then jumps to `_load_from_memory()`.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_19.png)

This function first maps some memory with mmap `mmap(0, arg2, 7, 0x1001, 0xFFFFFFFF, 0);` `0x1001` being `PROT_READ | PROT_WRITE | PROT_EXEC`. It then copies the decrypted payload into that memory and calls `_memory_exec2` at `0x100006e2b`. This function is a bit more complicated. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_20.png)

Essentially, this calls the Apple API method `NSCreateObjectFileImageFromMemory()` and creates an object file image from a memory buffer, more specifically, the payload placed in memory. `NSLinkModule` is then called to link it. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_21.png)

Next, it calls a function named `find_macho` which does as the name implies and searches the memory mapping for the mach magic number `0xfeedfacf`. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_22.png)

It then searches the payload for a value, `0x80000028`. This value is the Mach-O load command, so the payload decrypted from the server is a Mach-O file. The load command, `LC_MAIN`, contains various values as well as the entry point of the Mach-O binary. 

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_23.png)

The code finds the entry point at offset `0x8`, sets up some arguments (all `0`'s), and jumps to the entry point of the Mach-O in memory.

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_24.png)

So, to execute a payload straight from memory, the malware loads a download Mach-O file into memory using `mmap()` with protections `PROT_READ | PROT_WRITE | PROT_EXEC`, then it uses `NSCreateObjectFileImageFromMemory()` to create an object image using the Mach-O in memory, next it uses `NSLinkModule` to link the the module in memory, filling that it searches for the Mach-O magic number `0xfeedfacf` and then finds the address of `LC_MAIN` - the Mach-O load command, then at offset `0x8` it finds the entry pint to the Mach-O, sets up argument for the entry point, and jumps to it straight in memory.

And last but not least:

![Image](https://starwarsfan2099.github.io/public/2020-1-22/Pic_25.png)

If the function `_load_from_memory()` fails and returns `0`, it just copies the Mach-O to `/tmp/updater` and executes it with `system()`.
