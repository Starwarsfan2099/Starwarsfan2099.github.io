I"¥#<p>DJI Spark drones come with a companion application used to transfer files between the drone and the computer. Some mysterious log files can be transfered using application. However, they appear to be encrypted for some reason. Transfered DJI Spark Droneâ€™s log files look something like this after being transfered to a computer.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-25/Pic_1.png" alt="Image" /></p>

<p>The first step in figuring out how to decrypt the DJI Spark drone encrypted files is to analyze the firmware used by the drone. The firmware downloads for the Spark drone can be gotten from cache files in the DJI software after it has been used to update the drone, or it can be downloaded from DJIâ€™s servers using <a href="https://github.com/cs2000/DankDroneDownloader">DankDroneDownloader</a>. This tool can be used to download multiple versions of the firmware used on several different drones, including the Spark. Once the firmware is downloaded, you can extract the <code class="highlighter-rouge">.tar</code> file or <code class="highlighter-rouge">.bin</code> (still <code class="highlighter-rouge">.tar</code>, just renamed) depending on the firmware version. This will produce several <code class="highlighter-rouge">.sig</code> files. After extracting and exploring many <code class="highlighter-rouge">.sig</code> files, the main system layout and executables can be extracted. Looking for anything that could provide ftp support, the BusyBox executable was found in/   <code class="highlighter-rouge">system/xbin</code>. <a href="https://www.busybox.net/">BusyBox</a> is an open source tool containing many Linux tools and commands into one executable designed for embedded Linux systems. BusyBox does not contain any sort of encryption in its ftp source, so DJI must have added their own.</p>

<p>The system and BusyBox files can be extracted from the firmware <code class="highlighter-rouge">.sig</code> files by first searching them for BusyBox using <code class="highlighter-rouge">grep busybox wm* -r</code>. If grep finds the BusyBox in one of the files, the file system can be extracted with Binwalk, for example <code class="highlighter-rouge">binwalk -e wmÉ©É©0_0É¯0É¨.pro.fw.sig</code>. The next step was to figure out the encryption method. The binary could be reversed, but the binary includes a lot of functions to work through, so I chose to use a virtual environment to run BusyBox and inspect it from there. To get BusyBox running, I ran it in an Arm chroot with Qemu. I installed qemu-user-static with <code class="highlighter-rouge">sudo apt-get install qemu-user-static then told it to build the chroot with sudo qemu-debootstrap --arch armhf jessie eabi-chroot</code>. That installs and sets up an environment in a folder called <code class="highlighter-rouge">eabi-chroot</code>. To get BusyBox running, I copied the BusyBox binary into the root of the <code class="highlighter-rouge">eadi-chroot</code>. I also created a folder <code class="highlighter-rouge">ftp</code> in the root as well, as BusyBox looks for this folder when starting the ftp environment. Inside the <code class="highlighter-rouge">ftp</code> folder, I placed a <code class="highlighter-rouge">test.txt</code> file used to test if ftp was working or not. BusyBox can then be launched with <code class="highlighter-rouge">sudo chroot eabi-chroot</code>, then running <code class="highlighter-rouge">./busybox tcpsvd -vE 0.0.0.0 21 ./busybox ftpd -wv /tmp/</code> to get the ftp server running.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-25/Pic_2.png" alt="Image" /></p>

<p>Image 2. BusyBox FTP server running in Qemu. I then connected to the ftp server with the username <code class="highlighter-rouge">nouser</code> and requested a file.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-25/Pic_3.png" alt="Image" /></p>

<p>Image 2. FTP server successfully transferring files. <code class="highlighter-rouge">GDB</code> and <code class="highlighter-rouge">radare2</code> were attached to the process and <code class="highlighter-rouge">Ghidra</code> was used for static analysis to locate the file transfer functions. Now that a file has been requested, I used the debuggers and <code class="highlighter-rouge">Ghidra</code> to determine that the key wasplaced into memory. I used several different tools to look at the process memory for possible encryption keys or signatures, finally landing on <a href="https://github.com/mmozeiko/aes-finder">AES finder</a> and discovering it used AES encryption. The tool revealed DJI used an AES-128 bit encryption and it pulled the key from memory, but it did not find the IV. Now that the encryption and the AES key is known, it is significantly easier to look for specific encryption functions in the binary by searching for the AES key. Following the function where the AES key is used, it leads to the IV and later the packing used.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-25/Pic_4.png" alt="Image" /></p>

<p>Image 4. AES IV located inside the BusyBox binary shown with <code class="highlighter-rouge">Ghidra</code>. Knowing the AES key, the IV, and the packing, it is trivial to write asmall Python script to decrypt the files:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Created by Andrew Clark on 7/30/19
import sys, os 
from Crypto.Cipher import AES
from pkcs7 import PKCS7Encoder 
key = "YP1Nag7ZR&amp;Dj\x00\x00\x00\x00" 
iv  = "0123456789abcdef" 
aes = AES.new(key, AES.MODE_CBC, iv)

if len(sys.argv) &lt; 2:
    print "Usage: decrypt.py FILE"
    exit()
 else:
    if os.path.isfile(sys.argv[1]):                 
        print "Opening and decrypting file..."                 encryptedFile = open(sys.argv[1], 'rb').read()            decryptedFile = aes.decrypt(encryptedFile)
        encoding = PKCS7Encoder()
        decodedFile = encoding.decode(decryptedFile)
        outputFile = open(sys.argv[1] + ".decrypted", 'w+')
        outputFile.write(decodedFile)
        outputFile.close()
        print "Done. \nDecrypted file was written to %s" % sys.argv[1] + ".decrypted"
    else:
        print "Could not open file."
</code></pre></div></div>

<p>The IV did not change across drone versions, but the AES key did twice, the most recent versions all have the same key though. Knowing
the IV, it is now easiest to get the AES key for future versions by checking in a disassembler if the IV string is present and locating the AES
key in that same function. Or simply searching for the following bytes will produce the AES function: <code class="highlighter-rouge">06 30 9f e7 03 30 90 e7 02 00 53 e3 09 00 00 0a</code>.</p>

<p>In the end, the log files look like this:</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-25/Pic_5.png" alt="Image" /></p>

<p>The process outline for decrypting the drone data was as follows:</p>
<ul>
  <li>Obtain drone filesystem.
    <ul>
      <li>Done by searching for open source DJI Drone firmware downloading tools.</li>
    </ul>
  </li>
  <li>Determine how to extract drone firmware.
    <ul>
      <li>Completed by examining headers and using binwalk to extract the filesystem.</li>
    </ul>
  </li>
  <li>Determine what part of the firmware deals with log files.
    <ul>
      <li>Firmware was examined to determine what software ran on the drone.
        <ul>
          <li>After BusyBox was determined to be running on the drone, itâ€™s source code was analysed to find file transfer and logging functions.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Attempt to run drone software in a visualized environment for debugging.
    <ul>
      <li>I researched QEMU and visualizing embedded systems, trying various configurations to get BusyBox running.</li>
    </ul>
  </li>
  <li>Debug BusyBox to determine encryption.
    <ul>
      <li>GDB and RadareÉ© were used to debug and determine when the data was encrypted.
        <ul>
          <li>Ghidra was used to disassemble the BusyBox binary and locate the file transfer functions with help from the debuggers.
            <ul>
              <li>It was discovered that the key was put into memory, so open source tools were tested against the BusyBox process memory tp pull a key from memory.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Write a script to decrypt logs.
    <ul>
      <li>Knowing the key, the encryption could be determined and Ghidra was used to find the encryption functions to obtain the IV and packing type.
        <ul>
          <li>A Python script was written with open source libraries to decrypt the files with the appropriate key, IV, encryption, and packing.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Allow for easier obtaining of keys for future drone versions.
    <ul>
      <li>A unique byte pattern in the encryption function referencing the key and IV was found allowing for disassembler to search for the pattern and immediately obtain references to the key and IV.</li>
    </ul>
  </li>
</ul>
:ET