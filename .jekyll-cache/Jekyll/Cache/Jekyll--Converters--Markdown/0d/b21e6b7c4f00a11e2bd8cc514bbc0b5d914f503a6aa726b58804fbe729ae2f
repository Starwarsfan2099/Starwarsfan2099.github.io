I"2<p>This post was inspired by Dinesh Devadoss’s <a href="https://twitter.com/dineshdina04/status/1201834142704394242?s=20">post on twitter</a> about a piece of MacOS malware from the Lazarus group that loads a Mach-O into memory and executes it.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_1.png" alt="Image" /></p>

<p>Loading a Mach-O into memory to execute peeked my interest, and I wanted to know how it worked, and I was able to obtain a sample of the malware. The malware was obtained from <code class="highlighter-rouge">https://unioncrypto.vip/</code> , which is now down but resolved to <code class="highlighter-rouge">104.168.167.16</code>.</p>

<p>I first searched the MD5 hash of the file (<code class="highlighter-rouge">6588d262529dc372c400bef8478c2eec</code>) on VirusTotal. It had been uploaded and most of the major AV companies flag the malware.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_2.png" alt="Image" /></p>

<p>Using VirusTotal, we can get a lot of preliminary information about the malware. Some interesting information is files opened, written, and dropped.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_3.png" alt="Image" /></p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_4.png" alt="Image" /></p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_5.png" alt="Image" /></p>

<p>To inspect the file locally, first I mounted the disk image with <code class="highlighter-rouge">hdiutil attach UnionCryptoTrader.dmg</code>. It contained a single file named <code class="highlighter-rouge">UnionCryptoTrader.pkg</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_6.png" alt="Image" /></p>

<p>The package file was not singed, meaning MacOS would prompt the user with a warning before they could install the package.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_7.png" alt="Image" /></p>

<p>Examine the package file, I extracted the app installed, <code class="highlighter-rouge">UnionCryptoTrader.app</code> and any scripts within the package with resulted in a <code class="highlighter-rouge">postinstall</code> script.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_8.png" alt="Image" /></p>

<p>Before I jumped into the app executable, I wanted to see what the <code class="highlighter-rouge">postinstall</code> script did.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_9.png" alt="Image" /></p>

<p>In line 2, script moves a hidden plist file (<code class="highlighter-rouge">.vip.unioncrypto.plist</code>) from the app’s resources to the Launch Daemons directory, probably to give the app persistence across reboots or when a user logs out. The script then sets the plist to be owned by root in line 4. Since it does this, the user will also have to enter the root password to install this on their machine, hopefully adding some doubt to unsuspecting users. Line 6 creates a directory, and line 8 moves a hidden executable (<code class="highlighter-rouge">.unioncryptoupdater</code>) from the resources into the Library path. Line 10 sets executable permissions and line 12 executes the binary. Once this script runs successfully, <code class="highlighter-rouge">unioncryptoupdater</code> is running and is persistently installed to the machine.</p>

<p>Going to the app’s package contents, then using Command + Shift + . in finder, I could easily see the hidden files. Opening up the plist file shows <code class="highlighter-rouge">RunAtLoad</code> set to true, further confirming persistence.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_10.png" alt="Image" /></p>

<p>The file is a standard Mach-O 64 bit binary with ad-hoc code signing.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_11.png" alt="Image" /></p>

<p>Next, I looked at the strings in the binary.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl_easy_perform() failed: %s
Response &lt;
&gt; thrown.
AES_CYPHER_128 encrypt test case:
AES_CYPHER_128 decrypt test case:
AES_CYPHER_192 encrypt test case:
AES_CYPHER_192 decrypt test case:
AES_CYPHER_256 encrypt test case:
AES_CYPHER_256 decrypt test case:
Input:
IOPlatformExpertDevice
IOPlatformSerialNumber
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
ProductBuildVersion
Mac OS X %s (%s)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
/tmp/updater
%s %s
NO_ID
%s%s
12GWAPCT1F0I1S14
auth_timestamp
auth_signature
check
https://unioncrypto.vip/update
done
/bin/rcp
Could not create image.
core
Could not link image.
Could not find ec.
Could not resolve symbol: _sym[25] == 0x4d6d6f72.
Could not resolve symbol: _sym[4] == 0x4d6b6e69.
c|w{
9JLX
~=d]
lpHP
cU!}
"3DUfw
0123456789abcdef
dictionaryWithContentsOfFile:
objectForKey:
UTF8String
</code></pre></div></div>

<p>The first thing I noted was <code class="highlighter-rouge">curl_easy_perform() failed: %s</code>. The binary includes <code class="highlighter-rouge">libcurl</code> so it probably has some network functionality. Other things to note are<code class="highlighter-rouge"> IOPlatformExpertDevice</code>, <code class="highlighter-rouge">IOPlatformSerialNumber</code>, <code class="highlighter-rouge">/System/Library/CoreServices/SystemVersion.plist</code>, <code class="highlighter-rouge">ProductVersion</code>, and <code class="highlighter-rouge">ProductBuildVersion</code>. The malware appears to gather a lot of system information.</p>

<p>I then decided it was time to open the binary in a disassembler. The binary begins with the expected Mach-O signature <code class="highlighter-rouge">FE ED FA CF</code>. It does some setup stuff, then proceeds to a function appropriately named <code class="highlighter-rouge">onRun</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_12.png" alt="Image" /></p>

<p>The function proceeds to setup a class named <code class="highlighter-rouge">Barbeque</code>. It contains functions such as <code class="highlighter-rouge">Barbeque::get</code>, <code class="highlighter-rouge">Barbeque::post</code>, and includes references to <code class="highlighter-rouge">libcurl</code>, so it’s safe to assume this is the networking class for the malware. The function then calls another function named <code class="highlighter-rouge">getDeviceSerial</code> at <code class="highlighter-rouge">0x1000051f2</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_13.png" alt="Image" /></p>

<p>This code initializes IOKit, calls <code class="highlighter-rouge">IORegistryEntryCreateCFProperty</code> with the <code class="highlighter-rouge">IOPlatformSerialNumber</code> key, converts it to C string buffer with <code class="highlighter-rouge">CFStringGetCString</code>, and returns the serial number. The <code class="highlighter-rouge">onRun</code> function continues and calls a function named <code class="highlighter-rouge">getOSVersion</code> at <code class="highlighter-rouge">0x10000522a</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_14.png" alt="Image" /></p>

<p>This code reads the file <code class="highlighter-rouge">/System/Library/CoreServices/SystemVersion.plist</code> and reads the <code class="highlighter-rouge">ProductName</code>, <code class="highlighter-rouge">ProductUserVisibleVersion</code>, and <code class="highlighter-rouge">ProductBuildVersion</code> keys from the plist file and begins to build a string. Later in <code class="highlighter-rouge">onRun</code>, the current time is added to the string and the hardcoded values <code class="highlighter-rouge">\x31\x32\x47\x57\x41\x50\x43\x54\x31\x46\x30\x49\x31\x53\x31\x34</code> are appended to it.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_15.png" alt="Image" /></p>

<p>Next the malware invokes <code class="highlighter-rouge">Barbeque:post</code> which uses <code class="highlighter-rouge">libcurl</code> to send the string to <code class="highlighter-rouge">https://unioncrypto.vip/update</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_16.png" alt="Image" /></p>

<p>The malware then awaits a response. If the response is <code class="highlighter-rouge">0</code> the function jumps to <code class="highlighter-rouge">0x10000583f</code> which is a short function that calls <code class="highlighter-rouge">sleep()</code> for 10 minutes. However, if the server doesn’t return <code class="highlighter-rouge">0</code>, it base64 decodes the response and calls <code class="highlighter-rouge">processUpdate()</code> as seen in the following disassembly.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_17.png" alt="Image" /></p>

<p>And this is the first part of <code class="highlighter-rouge">processUpdate()</code>:</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_18.png" alt="Image" /></p>

<p>There are some checks to make sure the string is valid and then the string is AES decrypted as seen at the function call at <code class="highlighter-rouge">0x100004c85</code>. The malware then jumps to <code class="highlighter-rouge">_load_from_memory()</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_19.png" alt="Image" /></p>

<p>This function first maps some memory with mmap <code class="highlighter-rouge">mmap(0, arg2, 7, 0x1001, 0xFFFFFFFF, 0);</code> <code class="highlighter-rouge">0x1001</code> being <code class="highlighter-rouge">PROT_READ | PROT_WRITE | PROT_EXEC</code>. It then copies the decrypted payload into that memory and calls <code class="highlighter-rouge">_memory_exec2</code> at <code class="highlighter-rouge">0x100006e2b</code>. This function is a bit more complicated.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_20.png" alt="Image" /></p>

<p>Essentially, this calls the Apple API method <code class="highlighter-rouge">NSCreateObjectFileImageFromMemory()</code> and creates an object file image from a memory buffer, more specifically, the payload placed in memory. <code class="highlighter-rouge">NSLinkModule</code> is then called to link it.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_21.png" alt="Image" /></p>

<p>Next, it calls a function named <code class="highlighter-rouge">find_macho</code> which does as the name implies and searches the memory mapping for the mach magic number <code class="highlighter-rouge">0xfeedfacf</code>.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_22.png" alt="Image" /></p>

<p>It then searches the payload for a value, <code class="highlighter-rouge">0x80000028</code>. This value is the Mach-O load command, so the payload decrypted from the server is a Mach-O file. The load command, <code class="highlighter-rouge">LC_MAIN</code>, contains various values as well as the entry point of the Mach-O binary.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_23.png" alt="Image" /></p>

<p>The code finds the entry point at offset <code class="highlighter-rouge">0x8</code>, sets up some arguments (all <code class="highlighter-rouge">0</code>’s), and jumps to the entry point of the Mach-O in memory.</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_24.png" alt="Image" /></p>

<p>So, to execute a payload straight from memory, the malware loads a download Mach-O file into memory using <code class="highlighter-rouge">mmap()</code> with protections <code class="highlighter-rouge">PROT_READ | PROT_WRITE | PROT_EXEC</code>, then it uses <code class="highlighter-rouge">NSCreateObjectFileImageFromMemory()</code> to create an object image using the Mach-O in memory, next it uses <code class="highlighter-rouge">NSLinkModule</code> to link the the module in memory, filling that it searches for the Mach-O magic number <code class="highlighter-rouge">0xfeedfacf</code> and then finds the address of <code class="highlighter-rouge">LC_MAIN</code> - the Mach-O load command, then at offset <code class="highlighter-rouge">0x8</code> it finds the entry pint to the Mach-O, sets up argument for the entry point, and jumps to it straight in memory.</p>

<p>And last but not least:</p>

<p><img src="https://starwarsfan2099.github.io/public/2020-1-22/Pic_25.png" alt="Image" /></p>

<p>If the function <code class="highlighter-rouge">_load_from_memory()</code> fails and returns <code class="highlighter-rouge">0</code>, it just copies the Mach-O to <code class="highlighter-rouge">/tmp/updater</code> and executes it with <code class="highlighter-rouge">system()</code>.</p>
:ET