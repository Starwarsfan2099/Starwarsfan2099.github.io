<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Andrew Clark's Blog</title>
 <link href="https://starwarsfan2099.github.io/atom.xml" rel="self"/>
 <link href="https://starwarsfan2099.github.io/"/>
 <updated>2020-05-27T18:28:30-04:00</updated>
 <id></id>
 <author>
   <name>Andrew Clark</name>
   <email>clarkiv@masrhall.edu</email>
 </author>

 
 <entry>
   <title>Marchant "Silent Speed" Mechanical Calculator Repair and Operation.</title>
   <link href="/2020/05/26/marchant-calculator/"/>
   <updated>2020-05-26T00:00:00-04:00</updated>
   <id>https://starwarsfan2099.github.io/2020/05/26/marchant-calculator</id>
   <content type="html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;I was able to acquire a Marchant ACR8M “Silent Speed” mechanical calculator bought off of Ebay. This is the calculator after some light cleaning and repair.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5599_2.jpg&quot; alt=&quot;Front view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The calculator includes it’s serial number and patent information on the bottom of the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5618.jpg&quot; alt=&quot;Bottom view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5619.jpg&quot; alt=&quot;Patent info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The model number is listed as &lt;code class=&quot;highlighter-rouge&quot;&gt;ACR8M-161734&lt;/code&gt;. Serial numbers 161,000 - 165,00 were manufactured in 1942. Serial numbers and manufacture dates for the &lt;em&gt;Silent Speed&lt;/em&gt;, &lt;em&gt;Figuremaster&lt;/em&gt;, and &lt;em&gt;Figurmatic&lt;/em&gt; can be found on &lt;a href=&quot;http://www.vintagecalculators.com/html/marchant.html&quot;&gt;this page&lt;/a&gt;. The calculator was in very good condition. Outer panels have light scratching and flaking as well as decade old tape residue. The Marchant painted logos are still present in all places. With only minimal surface cleaning, the calculator looks quite nice. The tape residue is resistant to any cleaners I put on and is completely hardened. Attempts to scrape it off resulted in paint coming off as well so I have left it for now.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5606.jpg&quot; alt=&quot;Right view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5607.jpg&quot; alt=&quot;Back view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5609.jpg&quot; alt=&quot;Left view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5611.jpg&quot; alt=&quot;Keyboard view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The calculator has 8 key columns (&lt;code class=&quot;highlighter-rouge&quot;&gt;8M&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;ACR8M&lt;/code&gt;) ont the keyboard for digit entry. Each column consists of 1 - 9, with a 10th red key at the bottom. The bottom row of keys is used to clear or zero a individual column and set it back to zero. The keyboard only allows one key to be pressed at a time in each column. Pressing another key releases the previous one that was pressed in a column. The keyboard also contains 9 decimal indicators. They can be flipped over to a painted white side via the wheels below the zeroing keys. This is used to help keep track of decimal places.&lt;/p&gt;

&lt;p&gt;Test&lt;/p&gt;

&lt;h1 id=&quot;division-slow-motion-with-outer-panels-removed&quot;&gt;Division Slow Motion with Outer Panels Removed&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/right_side_veiw.gif&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Gif should be above ^^^&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Decrypting DJI Spark Drone Log Files</title>
   <link href="/2020/01/25/dji-spark-log-decryption/"/>
   <updated>2020-01-25T00:00:00-05:00</updated>
   <id>https://starwarsfan2099.github.io/2020/01/25/dji-spark-log-decryption</id>
   <content type="html">&lt;p&gt;DJI Spark drones come with a companion application used to transfer files between the drone and the computer. Some mysterious log files can be transfered using application. However, they appear to be encrypted for some reason. Transfered DJI Spark Drone’s log files look something like this after being transfered to a computer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_1.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first step in figuring out how to decrypt the DJI Spark drone encrypted files is to analyze the firmware used by the drone. The firmware downloads for the Spark drone can be gotten from cache files in the DJI software after it has been used to update the drone, or it can be downloaded from DJI’s servers using &lt;a href=&quot;https://github.com/cs2000/DankDroneDownloader&quot;&gt;DankDroneDownloader&lt;/a&gt;. This tool can be used to download multiple versions of the firmware used on several different drones, including the Spark. Once the firmware is downloaded, you can extract the &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar&lt;/code&gt; file or &lt;code class=&quot;highlighter-rouge&quot;&gt;.bin&lt;/code&gt; (still &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar&lt;/code&gt;, just renamed) depending on the firmware version. This will produce several &lt;code class=&quot;highlighter-rouge&quot;&gt;.sig&lt;/code&gt; files. After extracting and exploring many &lt;code class=&quot;highlighter-rouge&quot;&gt;.sig&lt;/code&gt; files, the main system layout and executables can be extracted. Looking for anything that could provide ftp support, the BusyBox executable was found in/   &lt;code class=&quot;highlighter-rouge&quot;&gt;system/xbin&lt;/code&gt;. &lt;a href=&quot;https://www.busybox.net/&quot;&gt;BusyBox&lt;/a&gt; is an open source tool containing many Linux tools and commands into one executable designed for embedded Linux systems. BusyBox does not contain any sort of encryption in its ftp source, so DJI must have added their own.&lt;/p&gt;

&lt;p&gt;The system and BusyBox files can be extracted from the firmware &lt;code class=&quot;highlighter-rouge&quot;&gt;.sig&lt;/code&gt; files by first searching them for BusyBox using &lt;code class=&quot;highlighter-rouge&quot;&gt;grep busybox wm* -r&lt;/code&gt;. If grep finds the BusyBox in one of the files, the file system can be extracted with Binwalk, for example &lt;code class=&quot;highlighter-rouge&quot;&gt;binwalk -e wmɩɩ0_0ɯ0ɨ.pro.fw.sig&lt;/code&gt;. The next step was to figure out the encryption method. The binary could be reversed, but the binary includes a lot of functions to work through, so I chose to use a virtual environment to run BusyBox and inspect it from there. To get BusyBox running, I ran it in an Arm chroot with Qemu. I installed qemu-user-static with &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install qemu-user-static then told it to build the chroot with sudo qemu-debootstrap --arch armhf jessie eabi-chroot&lt;/code&gt;. That installs and sets up an environment in a folder called &lt;code class=&quot;highlighter-rouge&quot;&gt;eabi-chroot&lt;/code&gt;. To get BusyBox running, I copied the BusyBox binary into the root of the &lt;code class=&quot;highlighter-rouge&quot;&gt;eadi-chroot&lt;/code&gt;. I also created a folder &lt;code class=&quot;highlighter-rouge&quot;&gt;ftp&lt;/code&gt; in the root as well, as BusyBox looks for this folder when starting the ftp environment. Inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;ftp&lt;/code&gt; folder, I placed a &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt; file used to test if ftp was working or not. BusyBox can then be launched with &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chroot eabi-chroot&lt;/code&gt;, then running &lt;code class=&quot;highlighter-rouge&quot;&gt;./busybox tcpsvd -vE 0.0.0.0 21 ./busybox ftpd -wv /tmp/&lt;/code&gt; to get the ftp server running.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_2.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 2. BusyBox FTP server running in Qemu. I then connected to the ftp server with the username &lt;code class=&quot;highlighter-rouge&quot;&gt;nouser&lt;/code&gt; and requested a file.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_3.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 2. FTP server successfully transferring files. &lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;radare2&lt;/code&gt; were attached to the process and &lt;code class=&quot;highlighter-rouge&quot;&gt;Ghidra&lt;/code&gt; was used for static analysis to locate the file transfer functions. Now that a file has been requested, I used the debuggers and &lt;code class=&quot;highlighter-rouge&quot;&gt;Ghidra&lt;/code&gt; to determine that the key wasplaced into memory. I used several different tools to look at the process memory for possible encryption keys or signatures, finally landing on &lt;a href=&quot;https://github.com/mmozeiko/aes-finder&quot;&gt;AES finder&lt;/a&gt; and discovering it used AES encryption. The tool revealed DJI used an AES-128 bit encryption and it pulled the key from memory, but it did not find the IV. Now that the encryption and the AES key is known, it is significantly easier to look for specific encryption functions in the binary by searching for the AES key. Following the function where the AES key is used, it leads to the IV and later the packing used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_4.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 4. AES IV located inside the BusyBox binary shown with &lt;code class=&quot;highlighter-rouge&quot;&gt;Ghidra&lt;/code&gt;. Knowing the AES key, the IV, and the packing, it is trivial to write asmall Python script to decrypt the files:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Created by Andrew Clark on 7/30/19
import sys, os 
from Crypto.Cipher import AES
from pkcs7 import PKCS7Encoder 
key = &quot;YP1Nag7ZR&amp;amp;Dj\x00\x00\x00\x00&quot; 
iv  = &quot;0123456789abcdef&quot; 
aes = AES.new(key, AES.MODE_CBC, iv)

if len(sys.argv) &amp;lt; 2:
    print &quot;Usage: decrypt.py FILE&quot;
    exit()
 else:
    if os.path.isfile(sys.argv[1]):                 
        print &quot;Opening and decrypting file...&quot;                 encryptedFile = open(sys.argv[1], 'rb').read()            decryptedFile = aes.decrypt(encryptedFile)
        encoding = PKCS7Encoder()
        decodedFile = encoding.decode(decryptedFile)
        outputFile = open(sys.argv[1] + &quot;.decrypted&quot;, 'w+')
        outputFile.write(decodedFile)
        outputFile.close()
        print &quot;Done. \nDecrypted file was written to %s&quot; % sys.argv[1] + &quot;.decrypted&quot;
    else:
        print &quot;Could not open file.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The IV did not change across drone versions, but the AES key did twice, the most recent versions all have the same key though. Knowing
the IV, it is now easiest to get the AES key for future versions by checking in a disassembler if the IV string is present and locating the AES
key in that same function. Or simply searching for the following bytes will produce the AES function: &lt;code class=&quot;highlighter-rouge&quot;&gt;06 30 9f e7 03 30 90 e7 02 00 53 e3 09 00 00 0a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the end, the log files look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_5.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The process outline for decrypting the drone data was as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Obtain drone filesystem.
    &lt;ul&gt;
      &lt;li&gt;Done by searching for open source DJI Drone firmware downloading tools.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Determine how to extract drone firmware.
    &lt;ul&gt;
      &lt;li&gt;Completed by examining headers and using binwalk to extract the filesystem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Determine what part of the firmware deals with log files.
    &lt;ul&gt;
      &lt;li&gt;Firmware was examined to determine what software ran on the drone.
        &lt;ul&gt;
          &lt;li&gt;After BusyBox was determined to be running on the drone, it’s source code was analysed to find file transfer and logging functions.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Attempt to run drone software in a visualized environment for debugging.
    &lt;ul&gt;
      &lt;li&gt;I researched QEMU and visualizing embedded systems, trying various configurations to get BusyBox running.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Debug BusyBox to determine encryption.
    &lt;ul&gt;
      &lt;li&gt;GDB and Radareɩ were used to debug and determine when the data was encrypted.
        &lt;ul&gt;
          &lt;li&gt;Ghidra was used to disassemble the BusyBox binary and locate the file transfer functions with help from the debuggers.
            &lt;ul&gt;
              &lt;li&gt;It was discovered that the key was put into memory, so open source tools were tested against the BusyBox process memory tp pull a key from memory.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Write a script to decrypt logs.
    &lt;ul&gt;
      &lt;li&gt;Knowing the key, the encryption could be determined and Ghidra was used to find the encryption functions to obtain the IV and packing type.
        &lt;ul&gt;
          &lt;li&gt;A Python script was written with open source libraries to decrypt the files with the appropriate key, IV, encryption, and packing.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Allow for easier obtaining of keys for future drone versions.
    &lt;ul&gt;
      &lt;li&gt;A unique byte pattern in the encryption function referencing the key and IV was found allowing for disassembler to search for the pattern and immediately obtain references to the key and IV.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Analyzing MacOS Malware that Executes a Payload in Memory</title>
   <link href="/2020/01/22/mac-malware/"/>
   <updated>2020-01-22T00:00:00-05:00</updated>
   <id>https://starwarsfan2099.github.io/2020/01/22/mac-malware</id>
   <content type="html">&lt;p&gt;This post was inspired by Dinesh Devadoss’s &lt;a href=&quot;https://twitter.com/dineshdina04/status/1201834142704394242?s=20&quot;&gt;post on twitter&lt;/a&gt; about a piece of MacOS malware from the Lazarus group that loads a Mach-O into memory and executes it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_1.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Loading a Mach-O into memory to execute peeked my interest and I wanted to know how it worked. So I obtained a sample of the malware from the website spreading it. The malware was obtained from &lt;code class=&quot;highlighter-rouge&quot;&gt;https://unioncrypto.vip/&lt;/code&gt; , which is now down but previously resolved to &lt;code class=&quot;highlighter-rouge&quot;&gt;104.168.167.16&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I first searched the MD5 hash of the file (&lt;code class=&quot;highlighter-rouge&quot;&gt;6588d262529dc372c400bef8478c2eec&lt;/code&gt;) on VirusTotal. It had been uploaded and most of the major AV companies flag the malware.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_2.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using VirusTotal, we can get a lot of preliminary information about the malware. Some interesting information is files opened, written, and dropped.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_3.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_4.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_5.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To inspect the file locally, first I mounted the disk image with &lt;code class=&quot;highlighter-rouge&quot;&gt;hdiutil attach UnionCryptoTrader.dmg&lt;/code&gt;. It contained a single file named &lt;code class=&quot;highlighter-rouge&quot;&gt;UnionCryptoTrader.pkg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_6.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The package file was not singed, meaning MacOS would prompt the user with a warning before they could install the package.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_7.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Examine the package file, I extracted the app installed, &lt;code class=&quot;highlighter-rouge&quot;&gt;UnionCryptoTrader.app&lt;/code&gt; and any scripts within the package with resulted in a &lt;code class=&quot;highlighter-rouge&quot;&gt;postinstall&lt;/code&gt; script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_8.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before I jumped into the app executable, I wanted to see what the &lt;code class=&quot;highlighter-rouge&quot;&gt;postinstall&lt;/code&gt; script did.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_9.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In line 2, script moves a hidden plist file (&lt;code class=&quot;highlighter-rouge&quot;&gt;.vip.unioncrypto.plist&lt;/code&gt;) from the app’s resources to the Launch Daemons directory, probably to give the app persistence across reboots or when a user logs out. The script then sets the plist to be owned by root in line 4. Since it does this, the user will also have to enter the root password to install this on their machine, hopefully adding some doubt to unsuspecting users. Line 6 creates a directory, and line 8 moves a hidden executable (&lt;code class=&quot;highlighter-rouge&quot;&gt;.unioncryptoupdater&lt;/code&gt;) from the resources into the Library path. Line 10 sets executable permissions and line 12 executes the binary. Once this script runs successfully, &lt;code class=&quot;highlighter-rouge&quot;&gt;unioncryptoupdater&lt;/code&gt; is running and is persistently installed to the machine.&lt;/p&gt;

&lt;p&gt;Going to the app’s package contents, then using Command + Shift + . in finder, I could easily see the hidden files. Opening up the plist file shows &lt;code class=&quot;highlighter-rouge&quot;&gt;RunAtLoad&lt;/code&gt; set to true, further confirming persistence.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_10.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The file is a standard Mach-O 64 bit binary with ad-hoc code signing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_11.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next, I looked at the strings in the binary.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_easy_perform() failed: %s
Response &amp;lt;
&amp;gt; thrown.
AES_CYPHER_128 encrypt test case:
AES_CYPHER_128 decrypt test case:
AES_CYPHER_192 encrypt test case:
AES_CYPHER_192 decrypt test case:
AES_CYPHER_256 encrypt test case:
AES_CYPHER_256 decrypt test case:
Input:
IOPlatformExpertDevice
IOPlatformSerialNumber
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
ProductBuildVersion
Mac OS X %s (%s)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
/tmp/updater
%s %s
NO_ID
%s%s
12GWAPCT1F0I1S14
auth_timestamp
auth_signature
check
https://unioncrypto.vip/update
done
/bin/rcp
Could not create image.
core
Could not link image.
Could not find ec.
Could not resolve symbol: _sym[25] == 0x4d6d6f72.
Could not resolve symbol: _sym[4] == 0x4d6b6e69.
c|w{
9JLX
~=d]
lpHP
cU!}
&quot;3DUfw
0123456789abcdef
dictionaryWithContentsOfFile:
objectForKey:
UTF8String
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first thing I noted was &lt;code class=&quot;highlighter-rouge&quot;&gt;curl_easy_perform() failed: %s&lt;/code&gt;. The binary includes &lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl&lt;/code&gt; so it probably has some network functionality. Other things to note are&lt;code class=&quot;highlighter-rouge&quot;&gt; IOPlatformExpertDevice&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IOPlatformSerialNumber&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/CoreServices/SystemVersion.plist&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductVersion&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductBuildVersion&lt;/code&gt;. The malware appears to gather a lot of system information.&lt;/p&gt;

&lt;p&gt;I then decided it was time to open the binary in a disassembler. The binary begins with the expected Mach-O signature &lt;code class=&quot;highlighter-rouge&quot;&gt;FE ED FA CF&lt;/code&gt;. It does some setup stuff, then proceeds to a function appropriately named &lt;code class=&quot;highlighter-rouge&quot;&gt;onRun&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_12.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The function proceeds to setup a class named &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque&lt;/code&gt;. It contains functions such as &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque::get&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque::post&lt;/code&gt;, and includes references to &lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl&lt;/code&gt;, so it’s safe to assume this is the networking class for the malware. The function then calls another function named &lt;code class=&quot;highlighter-rouge&quot;&gt;getDeviceSerial&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x1000051f2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_13.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This code initializes IOKit, calls &lt;code class=&quot;highlighter-rouge&quot;&gt;IORegistryEntryCreateCFProperty&lt;/code&gt; with the &lt;code class=&quot;highlighter-rouge&quot;&gt;IOPlatformSerialNumber&lt;/code&gt; key, converts it to C string buffer with &lt;code class=&quot;highlighter-rouge&quot;&gt;CFStringGetCString&lt;/code&gt;, and returns the serial number. The &lt;code class=&quot;highlighter-rouge&quot;&gt;onRun&lt;/code&gt; function continues and calls a function named &lt;code class=&quot;highlighter-rouge&quot;&gt;getOSVersion&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10000522a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_14.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This code reads the file &lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/CoreServices/SystemVersion.plist&lt;/code&gt; and reads the &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductName&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductUserVisibleVersion&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductBuildVersion&lt;/code&gt; keys from the plist file and begins to build a string. Later in &lt;code class=&quot;highlighter-rouge&quot;&gt;onRun&lt;/code&gt;, the current time is added to the string and the hardcoded values &lt;code class=&quot;highlighter-rouge&quot;&gt;\x31\x32\x47\x57\x41\x50\x43\x54\x31\x46\x30\x49\x31\x53\x31\x34&lt;/code&gt; are appended to it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_15.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next the malware invokes &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque:post&lt;/code&gt; which uses &lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl&lt;/code&gt; to send the string to &lt;code class=&quot;highlighter-rouge&quot;&gt;https://unioncrypto.vip/update&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_16.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The malware then awaits a response. If the response is &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; the function jumps to &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10000583f&lt;/code&gt; which is a short function that calls &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep()&lt;/code&gt; for 10 minutes. However, if the server doesn’t return &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, it base64 decodes the response and calls &lt;code class=&quot;highlighter-rouge&quot;&gt;processUpdate()&lt;/code&gt; as seen in the following disassembly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_17.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And this is the first part of &lt;code class=&quot;highlighter-rouge&quot;&gt;processUpdate()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_18.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are some checks to make sure the string is valid and then the string is AES decrypted as seen at the function call at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x100004c85&lt;/code&gt;. The malware then jumps to &lt;code class=&quot;highlighter-rouge&quot;&gt;_load_from_memory()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_19.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This function first maps some memory with mmap &lt;code class=&quot;highlighter-rouge&quot;&gt;mmap(0, arg2, 7, 0x1001, 0xFFFFFFFF, 0);&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0x1001&lt;/code&gt; being &lt;code class=&quot;highlighter-rouge&quot;&gt;PROT_READ | PROT_WRITE | PROT_EXEC&lt;/code&gt;. It then copies the decrypted payload into that memory and calls &lt;code class=&quot;highlighter-rouge&quot;&gt;_memory_exec2&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x100006e2b&lt;/code&gt;. This function is a bit more complicated.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_20.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essentially, this calls the Apple API method &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCreateObjectFileImageFromMemory()&lt;/code&gt; and creates an object file image from a memory buffer, more specifically, the payload placed in memory. &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLinkModule&lt;/code&gt; is then called to link it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_21.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next, it calls a function named &lt;code class=&quot;highlighter-rouge&quot;&gt;find_macho&lt;/code&gt; which does as the name implies and searches the memory mapping for the mach magic number &lt;code class=&quot;highlighter-rouge&quot;&gt;0xfeedfacf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_22.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It then searches the payload for a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80000028&lt;/code&gt;. This value is the Mach-O load command, so the payload decrypted from the server is a Mach-O file. The load command, &lt;code class=&quot;highlighter-rouge&quot;&gt;LC_MAIN&lt;/code&gt;, contains various values as well as the entry point of the Mach-O binary.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_23.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code finds the entry point at offset &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8&lt;/code&gt;, sets up some arguments (all &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;’s), and jumps to the entry point of the Mach-O in memory.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_24.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, to execute a payload straight from memory, the malware loads a download Mach-O file into memory using &lt;code class=&quot;highlighter-rouge&quot;&gt;mmap()&lt;/code&gt; with protections &lt;code class=&quot;highlighter-rouge&quot;&gt;PROT_READ | PROT_WRITE | PROT_EXEC&lt;/code&gt;, then it uses &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCreateObjectFileImageFromMemory()&lt;/code&gt; to create an object image using the Mach-O in memory, next it uses &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLinkModule&lt;/code&gt; to link the the module in memory, filling that it searches for the Mach-O magic number &lt;code class=&quot;highlighter-rouge&quot;&gt;0xfeedfacf&lt;/code&gt; and then finds the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;LC_MAIN&lt;/code&gt; - the Mach-O load command, then at offset &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8&lt;/code&gt; it finds the entry pint to the Mach-O, sets up argument for the entry point, and jumps to it straight in memory.&lt;/p&gt;

&lt;p&gt;And last but not least:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_25.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the function &lt;code class=&quot;highlighter-rouge&quot;&gt;_load_from_memory()&lt;/code&gt; fails and returns &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, it just copies the Mach-O to &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/updater&lt;/code&gt; and executes it with &lt;code class=&quot;highlighter-rouge&quot;&gt;system()&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
