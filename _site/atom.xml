<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Andrew Clark's Blog</title>
 <link href="https://starwarsfan2099.github.io/atom.xml" rel="self"/>
 <link href="https://starwarsfan2099.github.io/"/>
 <updated>2020-08-28T21:18:47-04:00</updated>
 <id></id>
 <author>
   <name>Andrew Clark</name>
   <email>clarkiv@masrhall.edu</email>
 </author>

 
 <entry>
   <title>Adding a "Four" loop to Clang Compiler</title>
   <link href="/2020/08/04/clang-four-loop/"/>
   <updated>2020-08-04T00:00:00-04:00</updated>
   <id>https://starwarsfan2099.github.io/2020/08/04/clang-four-loop</id>
   <content type="html">&lt;p&gt;What if a person was writing a C program and typoed their &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop. In C, a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop is written like &lt;code class=&quot;highlighter-rouge&quot;&gt;for( int i = 0; i &amp;lt; 12; i++) {...&lt;/code&gt;. What if they mistyped and instead wrote &lt;code class=&quot;highlighter-rouge&quot;&gt;four( int i = 0; i &amp;lt; 12; i++) {...&lt;/code&gt;? Well, if using llvm-clang, it will error out and fail to compile, understandable and expected. But that’s no fun. What if instead, it compiled fine and instead of looping over each iteration, it looped every four iterations because it’s a “four” loop?? That would be cool. Lets implement it into clang for fun and learning!&lt;/p&gt;

&lt;p&gt;First, we need to download and make sure we can build clang. The llvm project with llvm-clang can be found &lt;a href=&quot;https://github.com/llvm/llvm-project&quot;&gt;here on Github&lt;/a&gt;. First, clone the repository and associated dependencies with git.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/llvm/llvm-project.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we need to change directory to the llvm-clang directory and create a build directory. llvm-clang supports several build systems. I’m going to use &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; to configure the build scripts and then &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; to build everything. With &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;, we are going to pass &lt;code class=&quot;highlighter-rouge&quot;&gt;-DLLVM_ENABLE_PROJECTS=clang&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD=X86&lt;/code&gt; to enable building clang, and have clang only target x86 to speed up the compilation some. We’ll also pass ``-G “Unix Makefiles”&lt;code class=&quot;highlighter-rouge&quot;&gt; so we can use make to build everything. Next run &lt;/code&gt;make -j [number of threads]&lt;code class=&quot;highlighter-rouge&quot;&gt;. The &lt;/code&gt;-j&lt;code class=&quot;highlighter-rouge&quot;&gt; tells &lt;/code&gt;make&lt;code class=&quot;highlighter-rouge&quot;&gt; how many threads to use. llvm-clang takes fairly long to compile so we definitely want to use more than one thread. I'm using an 8 core MacBook Pro, so I used &lt;/code&gt;make -j 8`. Then patiently wait for clang to build.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd llvm-project
mkdir build
cd build
cmake -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -G &quot;Unix Makefiles&quot; ../llvm
make -j 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If clang builds successfully, you can find the binary in &lt;code class=&quot;highlighter-rouge&quot;&gt;build/bin&lt;/code&gt;. Now, we need to add our “four” loop. Opening the clang source code in Visual Studio is very overwhelming. There is &lt;strong&gt;a lot&lt;/strong&gt; of source code. After building llvm, there are 109880 files within the &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-project&lt;/code&gt; directory. Where do we start looking for the code associated with &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loops? We are interested in modifying clang, so a good first place to start is &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-project/clang&lt;/code&gt;. There are still a large amount of files here to though. We need a plan of action. Let’s see if we can modify the current &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop to only loop every four iterations. Delving into the source files in clang, we find &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/lib/CodeGen/&lt;/code&gt;. That looks promising since we want to modify the code generated for the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop. The files are named like &lt;code class=&quot;highlighter-rouge&quot;&gt;CGObjCRuntime.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;CGLoopInfo.cpp&lt;/code&gt;. There doesn’t seem to be anything to use of us in &lt;code class=&quot;highlighter-rouge&quot;&gt;CGLoopInfo.cpp&lt;/code&gt;. However, there is an interesting file named &lt;code class=&quot;highlighter-rouge&quot;&gt;CGStmt.cpp&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loops are &lt;a href=&quot;https://en.wikibooks.org/wiki/C_Programming/Statements&quot;&gt;iteration statements&lt;/a&gt; so this file could be useful. Searching the rather large file for the keyword “for” results in way to many results. Near the top of the file though, around line 140 are these lines:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case Stmt::IfStmtClass:      EmitIfStmt(cast&amp;lt;IfStmt&amp;gt;(*S));              break;
case Stmt::WhileStmtClass:   EmitWhileStmt(cast&amp;lt;WhileStmt&amp;gt;(*S), Attrs); break;
case Stmt::DoStmtClass:      EmitDoStmt(cast&amp;lt;DoStmt&amp;gt;(*S), Attrs);       break;
case Stmt::ForStmtClass:     EmitForStmt(cast&amp;lt;ForStmt&amp;gt;(*S), Attrs);     break;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EmitForStmt&lt;/code&gt; immediately stands out and could be interesting. &lt;code class=&quot;highlighter-rouge&quot;&gt;CodeGenFunction::EmitForStmt&lt;/code&gt; is found on line 882. By “Emit”, clang it is talking about exporting llvm bytecode. Comments reveal this code evaluates the loop and deals with increments. Further down in the function, it looks like we find where the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop is incremented!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// If there is an increment, emit it next.
if (S.getInc()) {
    EmitBlock(Continue.getBlock());
    EmitStmt(S.getInc());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To test this, we can copy &lt;code class=&quot;highlighter-rouge&quot;&gt;EmitStmt(S.getInc());&lt;/code&gt; 3 more times in the code block. So it should look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// If there is an increment, emit it next.
if (S.getInc()) {
    EmitBlock(Continue.getBlock());
    EmitStmt(S.getInc());
    EmitStmt(S.getInc());
    EmitStmt(S.getInc());
    EmitStmt(S.getInc());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, we need to recompile and test. To recompile, just run &lt;code class=&quot;highlighter-rouge&quot;&gt;make -j 8&lt;/code&gt; again. Then compile a program with a simple for loop and see what happens:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;For Loop
0
4
8
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Success! Kind of. Now the normal &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; statement increments by four, but we want the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop to be normal and add a &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; statement that increments by four. It’s going to be really difficult to add entirely new code to create our &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; loop. So, maybe we can modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop code that is already in place. We can create another function argument that gets passed all the way down to &lt;code class=&quot;highlighter-rouge&quot;&gt;CodeGenFunction::EmitForStmt&lt;/code&gt;. Then we can just add a different token in the lexer that looks for our &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; statement in the code and simply calls the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop code with the extra argument. What we need first is to find the lexer and tokens clang uses. The compiler lexer looks at the lines of code in the source file and determines what is a statement, string, operator, separator, etc… and a assigns a token to it that describes what it is. Then the tokens are used in later compilation steps. Based upon some quick Googling, tokens for clang are defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/include/clang/basic/TokenKinds.def&lt;/code&gt;. Doing a keyword search for the word “for” takes us to line 296:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KEYWORD(extern                      , KEYALL)
KEYWORD(float                       , KEYALL)
KEYWORD(for                         , KEYALL)
KEYWORD(goto                        , KEYALL)
KEYWORD(if                          , KEYALL)
KEYWORD(inline                      , KEYC99|KEYCXX|KEYGNU)
KEYWORD(int                         , KEYALL)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each statement is given a keyword assignment, so clang knows what terms are statements. The 2nd column are flags for the keyword. The flag &lt;code class=&quot;highlighter-rouge&quot;&gt;KEYALL&lt;/code&gt; means the statement is present in all variants of C or C++. &lt;code class=&quot;highlighter-rouge&quot;&gt;KEYC99&lt;/code&gt; and shown above means the feature was introduced in C99, and other flags can have other meanings that are described in the file. &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; is a statement present in all variations, so it has the flag &lt;code class=&quot;highlighter-rouge&quot;&gt;KEYALL&lt;/code&gt;. In order for clang to recognize &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; as a statement, we need to add our own keyword. Firstly, copy the line where &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; is defined as a keyword, paste the line right below it, and change the “for” to “four”. It should look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KEYWORD(float                       , KEYALL)
KEYWORD(for                         , KEYALL)
KEYWORD(four                        , KEYALL)
KEYWORD(goto                        , KEYALL)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we need to find the parser, where clang searches for the keywords in the source file. This logic can be found in &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/lib/Parse/ParseStmt.cpp&lt;/code&gt;. In this file, we find &lt;code class=&quot;highlighter-rouge&quot;&gt;Parser::ParseStatementOrDeclarationAfterAttributes&lt;/code&gt;. This function includes MANY case statements for finding statements in the source file. At line 266, we find this line:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  case tok::kw_for:                 // C99 6.8.5.3: for-statement
    return ParseForStatement(TrailingElseLoc);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This case statement assigns what happens when a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; statement is found. We want to copy this, and pass a function argument with it when the token &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; is found.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  case tok::kw_for:                 // C99 6.8.5.3: for-statement
    return ParseForStatement(TrailingElseLoc);
  case tok::kw_four:
    return ParseForStatement(TrailingElseLoc, true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Further down in the file, we find the function called if the token is found, &lt;code class=&quot;highlighter-rouge&quot;&gt;Parser::ParseForStatement&lt;/code&gt;. We need to modify it a bit. originally, the first few lines are written like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StmtResult Parser::ParseForStatement(SourceLocation *TrailingElseLoc) {
    assert(Tok.is(tok::kw_for) &amp;amp;&amp;amp; &quot;Not a for stmt!&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And we are going to modify it to look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StmtResult Parser::ParseForStatement(SourceLocation *TrailingElseLoc, bool is_four_statement) {
  if (is_four_statement) {
    assert(Tok.is(tok::kw_four) &amp;amp;&amp;amp; &quot;Not a four stmt!&quot;);
  } else {
    assert(Tok.is(tok::kw_for) &amp;amp;&amp;amp; &quot;Not a for stmt!&quot;);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we have added a &lt;code class=&quot;highlighter-rouge&quot;&gt;is_four_statement&lt;/code&gt; boolean function argument and added an assert to make sure it is a proper statement token. At line 2081, the function calls &lt;code class=&quot;highlighter-rouge&quot;&gt;Actions.ActOnForStmt&lt;/code&gt;. We need to pass our &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; statement boolean to that. So we change change this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return Actions.ActOnForStmt(ForLoc, T.getOpenLocation(), FirstPart.get(),
                              SecondPart, ThirdPart, T.getCloseLocation(),
                              Body.get());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return Actions.ActOnForStmt(ForLoc, T.getOpenLocation(), FirstPart.get(),
                              SecondPart, ThirdPart, T.getCloseLocation(),
                              Body.get(), is_four_statement);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ActOnForStmt&lt;/code&gt; can be found in &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/lib/Sema/SemaStmt.cpp&lt;/code&gt;. On line 1778, we need to change the function arguments here.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StmtResult Sema::ActOnForStmt(SourceLocation ForLoc, SourceLocation LParenLoc,
                              Stmt *First, ConditionResult Second,
                              FullExprArg third, SourceLocation RParenLoc,
                              Stmt *Body) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We simply pass our “four” loop boolean arguments here too.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StmtResult Sema::ActOnForStmt(SourceLocation ForLoc, SourceLocation LParenLoc,
                              Stmt *First, ConditionResult Second,
                              FullExprArg third, SourceLocation RParenLoc,
                              Stmt *Body, bool is_four_statement) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, we need to see where this function goes. This function calls &lt;code class=&quot;highlighter-rouge&quot;&gt;ForStmt&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  return new (Context)
      ForStmt(Context, First, Second.get().second, Second.get().first, Third,
              Body, ForLoc, LParenLoc, RParenLoc);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Same drill here, add our extra function arg we keep passing down through the functions.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  return new (Context)
      ForStmt(Context, First, Second.get().second, Second.get().first, Third,
              Body, ForLoc, LParenLoc, RParenLoc, is_four_statement);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForStmt&lt;/code&gt; is defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/lib/AST/Stmt.cpp&lt;/code&gt;. So again, we add our function argument to this function definition.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ForStmt::ForStmt(const ASTContext &amp;amp;C, Stmt *Init, Expr *Cond, VarDecl *condVar,
                 Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,
                 SourceLocation RP, bool is_four_statement)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;ForStmt::ForStmt&lt;/code&gt; sounds familiar, it’s used in the first code-gen file we modified, where the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop counter is actually incremented. While we’re still editing &lt;code class=&quot;highlighter-rouge&quot;&gt;Stmt.c&lt;/code&gt;, we need to add one more line. Around line 927, some variables for the function are assigned, we simply need to assign our function argument to a variable.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SubExprs[INC] = Inc;
SubExprs[BODY] = Body;
ForStmtBits.ForLoc = FL;
FourStatement = is_four_statement;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we head on over to the header file - &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/include/clang/AST/Stmt.h&lt;/code&gt;. We need to add our function argument in the public declaration on line 2460.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ForStmt(const ASTContext &amp;amp;C, Stmt *Init, Expr *Cond, VarDecl *condVar,
          Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,
          SourceLocation RP, bool is_four_statement=false);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we, we can access functions in this header from the code-gen file we modified earlier to test the increment. So we just need to add a function to return the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;FourStatement&lt;/code&gt;. Right below &lt;code class=&quot;highlighter-rouge&quot;&gt;getInit&lt;/code&gt;, we’ll add this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool isFourStatement() const { return FourStatement; }
bool FourStatement = false;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We set the variable to false afterwards so that way the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loops aren’t always in increments of four.&lt;/p&gt;

&lt;p&gt;Now we are through with that file and need to go back to &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/lib/CodeGen/CGStmt.cpp&lt;/code&gt;. Now we can change the block of code that increments the for loop to check if &lt;code class=&quot;highlighter-rouge&quot;&gt;FourStatement&lt;/code&gt; is true, and if so we increment three more times. In the function arguments of &lt;code class=&quot;highlighter-rouge&quot;&gt;EmitForStmt&lt;/code&gt;, we see the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;ForStmt&lt;/code&gt; is assigned to &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;. We can check our &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; loop boolean by simply checking &lt;code class=&quot;highlighter-rouge&quot;&gt;S.isFourStatement()&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (S.getInc()) {
    EmitBlock(Continue.getBlock());
    EmitStmt(S.getInc());

    if (S.isFourStatement()) {
      EmitStmt(S.getInc());
      EmitStmt(S.getInc());
      EmitStmt(S.getInc());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And we’re done! Now we need to go back to &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-project/build&lt;/code&gt; and rebuild clang again with &lt;code class=&quot;highlighter-rouge&quot;&gt;make -j 8&lt;/code&gt;. If no errors are found, we can now build a test program.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//four_test.c
int main() {
        printf(&quot;For Loop\n&quot;);
        for(int i = 0; i &amp;lt; 13; i++) {
                printf(&quot;%d\n&quot;, i);
        }

        printf(&quot;Four Loop\n&quot;);
        four(int i = 0; i &amp;lt; 13; i++) {
                printf(&quot;%d\n&quot;, i);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This should test if our &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; loops work. Now we build the program with the new clang that’s in &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-project/build/bin&lt;/code&gt; like so: &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/clang four_test.c -o four_test&lt;/code&gt;. Now run it and check the output!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AJ@AJs-Macbook-Pro build % ./four_test 
For Loop
0
1
2
3
4
5
6
7
8
9
10
11
12
Four Loop
0
4
8
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Success!!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Python Roman Numeral Code Golf</title>
   <link href="/2020/08/03/python-code-golf/"/>
   <updated>2020-08-03T00:00:00-04:00</updated>
   <id>https://starwarsfan2099.github.io/2020/08/03/python-code-golf</id>
   <content type="html">&lt;p&gt;A while back, a friend challenged me to a Python code golf. For those who don’t know, &lt;a href=&quot;https://www.wikiwand.com/en/Code_golf&quot;&gt;code golfing&lt;/a&gt; is a competition to see who can achieve a goal with the shortest amount of source code. My friend challenged me to write two Python functions. One function takes a number and returns its roman numeral equivalent as a string. The second function takes a roman numeral string as an argument and returns its numerical equivalent. A number of test cases were also given:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cases = {
        5: &quot;V&quot;,
        9: &quot;IX&quot;,
        12: &quot;XII&quot;,
        16: &quot;XVI&quot;,
        29: &quot;XXIX&quot;,
        44: &quot;XLIV&quot;,
        45: &quot;XLV&quot;,
        68: &quot;LXVIII&quot;,
        83: &quot;LXXXIII&quot;,
        97: &quot;XCVII&quot;,
        99: &quot;XCIX&quot;,
        500: &quot;D&quot;,
        501: &quot;DI&quot;,
        649: &quot;DCXLIX&quot;,
        798: &quot;DCCXCVIII&quot;,
        891: &quot;DCCCXCI&quot;,
        1000: &quot;M&quot;,
        1004: &quot;MIV&quot;,
        1006: &quot;MVI&quot;,
        1023: &quot;MXXIII&quot;,
        2014: &quot;MMXIV&quot;,
        3999: &quot;MMMCMXCIX&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My method is to first write code that accomplishes the goal, then attempt to shorten it and try other methods to accomplish the goal. The first code I came up with was:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def toRomanNumeral(input): # 560 Bytes
    values = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
    text = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')
    endText = []
    if not isinstance(input, int):
        raise Exception(&quot;[-] Error: expected int&quot;)
    if (input &amp;lt;= 0) or (input &amp;gt; 3999):
        raise Exception(&quot;[-] This function only works from 1 to 3999&quot;)
    for i in range(len(values)):
        endText.append(text[i] * int(input / values[i]))
        input -= values[i] * int(input / values[i])
    return ''.join(endText)

def fromRomanNumeral(input): # 637 Bytes
    valuesDict = {'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1}
    endValue = 0
    if not isinstance(input, basestring):
        raise Exception(&quot;[-] Error: Needs a string passed&quot;)
    input = input.upper()
    for i in range(len(input)):
        try:
            currentValue = valuesDict[input[i]]
            if (i + 1 &amp;lt; len(input)) and (valuesDict[input[i+1]] &amp;gt; currentValue):
                endValue -= currentValue
            else:
                endValue += currentValue
        except:
             raise Exception(&quot;[-] Error: input is not a valid roman numeral&quot;)
    return endValue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fromRomanNumeral&lt;/code&gt; is 638 bytes in length, and &lt;code class=&quot;highlighter-rouge&quot;&gt;toRomanNumeral&lt;/code&gt; is 561 bytes in length. Not very good. But this is only the initial starting code, and lots can be improved. First, we have all our test cases already, which means we know what the function arguments will be so there is no need for error checking the function inputs or values.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def toRomanNumeral(input): # 364 Bytes
    values = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
    text = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')
    endText = []
    for i in range(len(values)):
        endText.append(text[i] * int(input / values[i]))
        input -= values[i] * int(input / values[i])
    return ''.join(endText)

def fromRomanNumeral(input): # 408 Bytes
    valuesDict = {'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1}
    endValue = 0
    input = input.upper()
    for i in range(len(input)):
        currentValue = valuesDict[input[i]]
        if (i + 1 &amp;lt; len(input)) and (valuesDict[input[i+1]] &amp;gt; currentValue):
            endValue -= currentValue
        else:
            endValue += currentValue
    return endValue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s a bit better. 408 bytes and 364 bytes. Next thing, variable and function names are taking up lots of space, so we can reduce each name down to one letter.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def r(n): # 286 Bytes
    v = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
    t = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')
    e = []
    for i in range(len(v)):
        e.append(t[i] * int(n / v[i]))
        n -= v[i] * int(n / v[i])
    return ''.join(e)

def s(n): # 266 Bytes
    v = {'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1}
    e = 0
    n = n.upper()
    for i in range(len(n)):
        c = v[n[i]]
        if (i + 1 &amp;lt; len(n)) and (v[n[i+1]] &amp;gt; c):
            e -= c
        else:
            e += c
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sweet, now they are both below 300 bytes. But there is still much room for improvement. How we currently assign variables uses a lot of unneeded space. In the function &lt;code class=&quot;highlighter-rouge&quot;&gt;toRomanNumerals()&lt;/code&gt;, now simply named &lt;code class=&quot;highlighter-rouge&quot;&gt;r()&lt;/code&gt;, we define variables on separate lines. this means we use three spaces, three equal signs, then 3 more spaces. Fortunately, Python allows us to do this a different way. Instead of saying:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
t = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')
e = []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can instead declare the variables on one line like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v,t,e=(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1),('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'),[]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The current way of defining variables uses 141 bytes. Defining them on the same line uses 123 bytes. While we’re at it, &lt;code class=&quot;highlighter-rouge&quot;&gt;('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')&lt;/code&gt; can be shortened. Those repeated quotes use a lot of bytes. Instead of directly declaring an array (71 bytes), we can make a single string with spaces and use &lt;code class=&quot;highlighter-rouge&quot;&gt;.split()&lt;/code&gt; to create an array like this: &lt;code class=&quot;highlighter-rouge&quot;&gt;'M CM D CD C XC L XL X IX V IV I'.split()&lt;/code&gt; (41 bytes). We can also remove spaces from between the numbers defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the other function &lt;code class=&quot;highlighter-rouge&quot;&gt;fromRomanNumeral()&lt;/code&gt;, now named &lt;code class=&quot;highlighter-rouge&quot;&gt;s()&lt;/code&gt;, we can shorten the variable declaration there too in the same way. Right now the function declares variables like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v = {'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1}
e = 0
n = n.upper()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n = n.upper()&lt;/code&gt; is not needed, it was just a sanity check for the input to the function. &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; can be declared on the same line. Instead of declaring a dictionary for &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; with brackets then strings and ints, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;dict()&lt;/code&gt; to declare a dictionary like &lt;code class=&quot;highlighter-rouge&quot;&gt;dict(M:1000,D:500...)&lt;/code&gt;. This saves bytes from having to use quotes, and we can again remove spaces. This leaves us with:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v,e=dict(M=1000,D=500,C=100,L=50,X=10,V=5,I=1),0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can also save an extra byte here by using exponential notation for declaring the dictionary value &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;. Instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;M=1000&lt;/code&gt; it can be wrote like &lt;code class=&quot;highlighter-rouge&quot;&gt;M=1e3&lt;/code&gt;. Now the functions look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def r(n): # 230 Bytes
    v,t,e=(1000,900,500,400,100,90,50,40,10,9,5,4,1),'M CM D CD C XC L XL X IX V IV I'.split(),[]
    for i in range(len(v)):
        e.append(t[i] * int(n / v[i]))
        n -= v[i] * int(n / v[i])
    return ''.join(e)

def s(n): # 223 Bytes
    v,e=dict(M=1e3,D=500,C=100,L=50,X=10,V=5,I=1),0
    for i in range(len(n)):
        c = v[n[i]]
        if (i + 1 &amp;lt; len(n)) and (v[n[i+1]] &amp;gt; c):
            e -= c
        else:
            e += c
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All of the test cases still succeed. Looking at function &lt;code class=&quot;highlighter-rouge&quot;&gt;r()&lt;/code&gt;, it’s logic can be greatly improved. Instead of using &lt;code class=&quot;highlighter-rouge&quot;&gt;for i in range(len(v)):&lt;/code&gt;, we can simply loop over &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; and define &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; above. This saves space and allows us to shorten the logic below. Also, instead of declaring &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; as an empty array and using &lt;code class=&quot;highlighter-rouge&quot;&gt;.join()&lt;/code&gt; later, we can just declare &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; as an empty string and add to that.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def r(n): # 194 Bytes
    v,t,e,i=(1000,900,500,400,100,90,50,40,10,9,5,4,1),'M CM D CD C XC L XL X IX V IV I'.split(),'',0
    for a in v:
        e += n/a * t[i]
        n %= a
        i += 1
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Furthermore, we can remove spaces from between the operators inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop. Then we can add semicolons to the end of each line to get the entire for loop and operations within on the same line. This gets us to 162 bytes from the original 560!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def r(n): # 560 Bytes
    v,t,e,i=(1000,900,500,400,100,90,50,40,10,9,5,4,1),'M CM D CD C XC L XL X IX V IV I'.split(),'',0
    for a in v:e+=n/a*t[i];n%=a;i+=1;
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we turn our attention back to function &lt;code class=&quot;highlighter-rouge&quot;&gt;s()&lt;/code&gt;. Again, instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;for i in range(len(input)):&lt;/code&gt;, we can just declare &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; above and in this case loop over the input &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;. Changing the logic below results with:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def s(n): # 215 Bytes
    v,e,i=dict(M=1e3,D=500,C=100,L=50,X=10,V=5,I=1),0,0
    for a in n:
        if i+1&amp;lt;len(n) and v[n[i+1]]&amp;gt;v[a]:
            e = e - v[a]
        else:
            e = e + v[a]
        i += 1
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once again, we can remove space from operators. Then we can use &lt;a href=&quot;https://www.wikiwand.com/en/%3F:#/Python&quot;&gt;ternary operators&lt;/a&gt; to move the if and else statement to one line. Ternary operators work in the form of &lt;code class=&quot;highlighter-rouge&quot;&gt;result = x if a &amp;gt; b else y&lt;/code&gt;. Using this, we can put most of the logic and &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop on the same line. Also on the same line, we can add a semicolon and add our &lt;code class=&quot;highlighter-rouge&quot;&gt;i+=1;&lt;/code&gt; and have the entire &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop and logic on the same line.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def s(n): # 153 Bytes
    v,e,i=dict(M=1e3,D=500,C=100,L=50,X=10,V=5,I=1),0,0
    for a in n:e=e-v[a] if i+1&amp;lt;len(n) and v[n[i+1]]&amp;gt;v[a] else e+v[a];i+=1;
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally, conditionals following parentheses, brackets, or braces do not to have a space between them. This leaves us with the following golfed functions.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def r1(n): # 163 Bytes
    v,e,t,i=(1000,900,500,400,100,90,50,40,10,9,5,4,1),'','M CM D CD C XC L XL X IX V IV I'.split(),0
    for a in v:e+=n/a*t[i];n%=a;i+=1;
    return e

def s1(n): # 151 Bytes
    v,e,i=dict(M=1e3,D=500,C=100,L=50,X=10,V=5,I=1),0,0
    for a in n:e=e-v[a]if i+1&amp;lt;len(n)and v[n[i+1]]&amp;gt;v[a]else e+v[a];i+=1;
    return e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;163 and 151 bytes is significantly better than the 560 and 637 bytes we started out with. Happy golfing!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Marchant "Silent Speed" Mechanical Calculator Repair and Operation.</title>
   <link href="/2020/05/26/marchant-calculator/"/>
   <updated>2020-05-26T00:00:00-04:00</updated>
   <id>https://starwarsfan2099.github.io/2020/05/26/marchant-calculator</id>
   <content type="html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;I was able to acquire a Marchant ACR8M “Silent Speed” mechanical calculator bought off of Ebay. This is the calculator after some light cleaning and repair.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5599_2.jpg&quot; alt=&quot;Front view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The calculator includes its serial number and patent information on the bottom of the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5618.JPG&quot; alt=&quot;Bottom view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5619.JPG&quot; alt=&quot;Patent info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Marchant calculators were top of the line machines throughout the early 1900s. The &lt;em&gt;Silent Speed&lt;/em&gt; was among the fastest of any mechanical calculators ever made thanks to a unique and ingenious proportional drive mechanism. Division was among the fastest as well thanks to decaded mechanism for anticipating an underflow, saving machine cycles.&lt;/p&gt;

&lt;p&gt;The model number is listed for this machine as &lt;code class=&quot;highlighter-rouge&quot;&gt;ACR8M-161734&lt;/code&gt;. Serial numbers 161,000 - 165,00 were manufactured in 1942. Serial numbers and manufacture dates for the &lt;em&gt;Silent Speed&lt;/em&gt;, &lt;em&gt;Figuremaster&lt;/em&gt;, and &lt;em&gt;Figurmatic&lt;/em&gt; can be found on &lt;a href=&quot;http://www.vintagecalculators.com/html/marchant.html&quot;&gt;this page&lt;/a&gt;. The calculator was in very good condition. Outer panels have light scratching and flaking as well as decade old tape residue. The Marchant painted logos are still present in all places. With only minimal surface cleaning, the calculator looks quite nice. The tape residue is resistant to any cleaners I put on and is completely hardened. Attempts to scrape it off resulted in paint coming off as well so I have left it for now.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5606.JPG&quot; alt=&quot;Right view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5607.JPG&quot; alt=&quot;Back view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5609.JPG&quot; alt=&quot;Left view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/register.PNG&quot; alt=&quot;Register view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The carriage contains a 9 digit counter register and a 16 digit accumulator register. Both registers carry automatically. There multiple sliders for keeping track of decimals on both registers. An arrow shows above the current counter position (over the 8th digit in the picture). To the left of the counter register are 6 tab setting buttons labeled 1 - 8. The tab buttons, when pressed, cause the carriage to stop at a certain position after an operation or tab return.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5611.JPG&quot; alt=&quot;Keyboard view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The calculator has 8 key columns (&lt;code class=&quot;highlighter-rouge&quot;&gt;8M&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;ACR8M&lt;/code&gt;) on the keyboard for digit entry. Each column consists of 1 - 9, with a 10th red key at the bottom. The bottom row of keys is used to clear or zero a individual column and set it back to zero. The keyboard only allows one key to be pressed at a time in each column. Pressing another key releases the previous one that was pressed in a column. The keyboard also contains 9 decimal indicators. They can be flipped over to a painted white side via the wheels below the zeroing keys. This is used to help keep track of decimal places. Above the keyboard is a display register that shows the currently pressed keys on the keyboard.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5610.JPG&quot; alt=&quot;Controls view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Beside the keyboard, there are control keys and another column of keys. In the top right, is a red auto division key. To the right, is the division stop key. Below that row is the addition and subtraction keys. To the right of the subtraction keys is the carriage shift-direction keys. There is a shift left, no shift, and shift right key. These keys determine which way the carriage moves during tabulation and during multiplication. Below those three keys is a reverse key. The reverse key, when set, does the opposite of the operation pressed (addition or subtraction).&lt;/p&gt;

&lt;p&gt;In-between the reverse and addition keys is a small lever. This lever, when set downwards, causes the carriage return to a position determined by which shift-key is currently set and clear the accumulator register after division. If the shift right key is pressed and the lever is down, after a division the carriage will automatically return to the right and clear the accumulator register. If the lever is in the up position the carriage will not move or clear after a division.&lt;/p&gt;

&lt;p&gt;In the bottom left is the keyboard clear button. This key clears all columns on the keyboard. To the right of that key, is the tab and clear keys. The clear tab key returns the machine to position determined by the shift-keys. Below the tab key are two carriage clear keys. A accumulator register clear key and a counter register clear key. All three keys can be pressed at the same time.&lt;/p&gt;

&lt;p&gt;To the right of those keys, is a column of digits. This is the &lt;em&gt;“on-the-fly”&lt;/em&gt; multiplier. Pressing these keys multiplies what is in the accumulator register by the key pressed, and increments the counter register by that amount. The carriage then moves in the direction determined by the shift key setting. If no shift is pressed, the carriage does not shift.&lt;/p&gt;

&lt;p&gt;In the top right, beside the multiplier column, is another small lever. This lever reverses the counter register. When the lever is in the up position, the counter register increments with each operation. If the lever is down, the calculator decrements with each operation.&lt;/p&gt;

&lt;p&gt;On the far right, are two “manual” carriage shift buttons. The buttons shift the carriage one position, or until the button is released. If the carriage cannot go any further and a carriage shift is initiated, the motor turns on for a second then the machine stops.&lt;/p&gt;

&lt;h2 id=&quot;operation&quot;&gt;Operation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Addition:&lt;/strong&gt; Single addition is simple and the same as on many other keyboard mechanical calculators. A first number is entered on the keyboard and the &lt;em&gt;Addition&lt;/em&gt; key is pressed. This places the number in the accumulator register. The counter register is incremented by one. The keyboard is automatically cleared. Another number can be entered on the keyboard. When the addition key is pressed again, the product of the addition is in the accumulator register. For repeated additions less than 10 times, the number should be entered on the keyboard, then the addition key pressed at the same time as the multiplier row key for the number of successive additions you want. The carriage will not shift after this operation no matter of the shift key setting. The counter register is incremented by the number of additions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Subtraction:&lt;/strong&gt; Subtraction is essentially the same process as addition except using the subtraction key. Repeated subtractions use the same method as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Multiplication:&lt;/strong&gt; The &lt;em&gt;Silent Speed&lt;/em&gt; features a dedicated multiplier row for fast multiplication. The multiplier can be entered forwards or backwards. To enter the multiplier forward, the &lt;em&gt;left-shift&lt;/em&gt; key should be pressed. If the carriage is not in the most right position, the &lt;em&gt;Clear Tab&lt;/em&gt; key can be pressed to move the carriage all the way to the right. The multiplicand should be entered on the keyboard. Then the multiplier is entered digit by digit using the multiplier row. The carriage automatically shifts after each multiplication. The &lt;em&gt;Silent Speed&lt;/em&gt; also features a mechanical buffer system, meaning the next digit of the multiplier can be entered before the previous operations has even finished. This combined with the speed of the machine means the multiplier can be entered continuously with no waiting for the machine to finish an operation. If the &lt;em&gt;Right-shift&lt;/em&gt; key is pressed, the carriage will move to the right, so the multiplies will need to be entered from the last digit to first. The result is stored in the accumulator register, with the multiplier in the counter register.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Division:&lt;/strong&gt; The &lt;em&gt;Silent Speed&lt;/em&gt; has one of the fastest auto-division mechanism of any mechanical calculator ever made. First, the carriage must be placed all the way to the right via the manual carriage shift key or a &lt;em&gt;Left shift&lt;/em&gt; key set then &lt;em&gt;Clear Tab&lt;/em&gt;. First, the dividend is entered on the far left side of the keyboard for the most accuracy (via more decimal places). This number is placed in the accumulator register with the addition key. The divisor should be entered on the keyboard next. The counter register shows a 1 but is automatically cleared before division. The &lt;em&gt;Auto divide&lt;/em&gt; is then pressed. The machine will automatically perform the division. The quotient is in the counter register. If the &lt;em&gt;Division return&lt;/em&gt; lever is in the down position, the carriage will automatically return home and clear the remainder from the accumulator register. Otherwise, the division stops when the carriage has reached its maximum right position.&lt;/p&gt;

&lt;h2 id=&quot;outer-panels-removed&quot;&gt;Outer Panels Removed&lt;/h2&gt;

&lt;p&gt;The outer covers on the body of the machine are easily taken off via 12 screws. First the back panel is removed followed by the two side panels.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5614.JPG&quot; alt=&quot;Back panel removed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5616.JPG&quot; alt=&quot;Back panel removed 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5622.JPG&quot; alt=&quot;Right panel removed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5627.JPG&quot; alt=&quot;Right panel removed 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5646.JPG&quot; alt=&quot;Left panel removed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The carriage has three panels easily taken off the machine as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5648.JPG&quot; alt=&quot;Carriage panel removed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Removing the panels shows a glimpse of the mechanical complexity inside the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5649.JPG&quot; alt=&quot;Complexity&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;repair-and-some-inner-workings&quot;&gt;Repair and Some Inner Workings&lt;/h2&gt;

&lt;p&gt;Initially the, keyboard on the calculator arrived with multiple keys pressed in a single column. The keys were popped up using a large flat-head screwdriver and were fine after that. No control keys were pressed except for the manual left shift key. When the machine was plugged up, the carriage continually tried to shift left even though it was at the maximum right position. The manual shift left button was stuck down. Applying some oil to the two nuts on the left-hand side of the following photo and pulling on the button released it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5655.JPG&quot; alt=&quot;Shift stuck&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The carriage stopped attempting to shift but the motor still ran continuously. Inspecting the machine revealed the machine was at the end of a cycle but the control latches were still in place keeping the machine running. The culprit was the main clutch at the top-back of the control unit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5654.JPG&quot; alt=&quot;Main clutch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Removed from the machine, the clutch looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5674.JPG&quot; alt=&quot;Main clutch taken out&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The clutch has a visible spring loaded cam that should disengage at the end of an operation. This cam allows for the spring loaded drive pawls on the clutch to be engaged or disengaged. Several clutch dogs rest against these drive pawls and release control unit latches, specifically one keeps the motor engaged or disengages it. The main clutch is also connected to a reverse clutch and many other drive lines. Here is another view of the main clutch assembly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5675.JPG&quot; alt=&quot;Main clutch assembly&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Popping the cam forwards with a screwdriver, oiling the clutch, and repeating the process freed it up properly after about three tries.&lt;/p&gt;

&lt;p&gt;Multiplication got stuck often or didn’t move as well. Playing with the multiplication and more disassembly eventually showed several parts that were stuck thanks to old oil or grease. The first part was this piece connected to the multiplication column.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5663.JPG&quot; alt=&quot;Multiply repair 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At the left-center of the picture are two pieces diagonally connected downwards to the same shaft. These had a large amount of buildup on them.&lt;/p&gt;

&lt;p&gt;Another piece that was also stuck can be seen on the bottom of the control unit and freed up after some oiling. The piece can be seen left of center with a large flat bolt head.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5682.JPG&quot; alt=&quot;Multiply repair 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Occasional register sticking was occurring, so it’s a good practice to regularly oil the carriage dials. The Marchant &lt;em&gt;Silent Speed&lt;/em&gt; machine carriage digits have a unique mechanism from other calculators. Thanks to the proportional drive mechanism, another digit carry mechanism was needed. Each digit in a register is connected to the next left digit in the register. One full rotation of a digit rotates the next digit 1/10th, and the next left digit 1/100th, and so forth. Because a digit can be not centered thanks to the proportional gearing, a selector unit is in place to ensure each digit is properly determined, centered, and displayed. This, the clearing mechanism, and the division trip mechanism results in a lot of gears and moving parts that could get stuck.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5670.JPG&quot; alt=&quot;Carriage repair 2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;division-video&quot;&gt;Division Video&lt;/h2&gt;

&lt;p&gt;A video showing multiple angles of the machine performing division with the outer panels removed can be found &lt;a href=&quot;https://youtu.be/oJXJmg73SL4&quot;&gt;here on my YouTube channel&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;division-slow-motion-video&quot;&gt;Division Slow Motion Video&lt;/h2&gt;

&lt;p&gt;Also, a slow motion video showing multiple angles of the machine performing division with the outer panels removed can be found &lt;a href=&quot;https://www.youtube.com/watch?v=PnmSc-vCM5Q&quot;&gt;on my YouTube channel as well&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;more-pictures&quot;&gt;More Pictures&lt;/h2&gt;

&lt;p&gt;The Westinghouse motor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5617.JPG&quot; alt=&quot;Motor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Setting gears, clearing levers, main motor input drive with safety clutch, and the contact to turn on the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5660.JPG&quot; alt=&quot;Gearing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Motor input and safety clutch removed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5677.JPG&quot; alt=&quot;Motor input&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Multiplication column removed from the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5684.JPG&quot; alt=&quot;Multiplication Column&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Removable button plate with addition, subtraction, and keyboard clear levers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5686.JPG&quot; alt=&quot;Button Plate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Partially disassembled control unit taken off the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5679.JPG&quot; alt=&quot;Control Unit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Right side of machine with control unit removed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5687.JPG&quot; alt=&quot;Control Unit Gone&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Carriage shift gear and maximum shift lever seen above the carriage dial contact gears.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5689.JPG&quot; alt=&quot;Carriage Shift&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Carriage contact gears.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5688.JPG&quot; alt=&quot;Carriage Contact&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Carriage clearing arms, underside of carriage, and digit closeup.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5671.JPG&quot; alt=&quot;Carriage Clearing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5672.JPG&quot; alt=&quot;Carriage Bottom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5657.JPG&quot; alt=&quot;Digit Closeup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Bottom of the machine with baseplate removed. Keyboard selector levers can be seen as well as the main setting line for the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-5-26/DSC_5690.JPG&quot; alt=&quot;Bottom&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Decrypting DJI Spark Drone Log Files</title>
   <link href="/2020/01/25/dji-spark-log-decryption/"/>
   <updated>2020-01-25T00:00:00-05:00</updated>
   <id>https://starwarsfan2099.github.io/2020/01/25/dji-spark-log-decryption</id>
   <content type="html">&lt;p&gt;DJI Spark drones come with a companion application used to transfer files between the drone and the computer. Some mysterious log files can be transferred using application. However, they appear to be encrypted for some reason. transferred DJI Spark Drone’s log files look something like this after being transferred to a computer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_1.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first step in figuring out how to decrypt the DJI Spark drone encrypted files is to analyze the firmware used by the drone. The firmware downloads for the Spark drone can be gotten from cache files in the DJI software after it has been used to update the drone, or it can be downloaded from DJI’s servers using &lt;a href=&quot;https://github.com/cs2000/DankDroneDownloader&quot;&gt;DankDroneDownloader&lt;/a&gt;. This tool can be used to download multiple versions of the firmware used on several different drones, including the Spark. Once the firmware is downloaded, you can extract the &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar&lt;/code&gt; file or &lt;code class=&quot;highlighter-rouge&quot;&gt;.bin&lt;/code&gt; (still &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar&lt;/code&gt;, just renamed) depending on the firmware version. This will produce several &lt;code class=&quot;highlighter-rouge&quot;&gt;.sig&lt;/code&gt; files. After extracting and exploring many &lt;code class=&quot;highlighter-rouge&quot;&gt;.sig&lt;/code&gt; files, the main system layout and executables can be extracted. Looking for anything that could provide ftp support, the BusyBox executable was found in/   &lt;code class=&quot;highlighter-rouge&quot;&gt;system/xbin&lt;/code&gt;. &lt;a href=&quot;https://www.busybox.net/&quot;&gt;BusyBox&lt;/a&gt; is an open source tool containing many Linux tools and commands into one executable designed for embedded Linux systems. BusyBox does not contain any sort of encryption in its ftp source, so DJI must have added their own.&lt;/p&gt;

&lt;p&gt;The system and BusyBox files can be extracted from the firmware &lt;code class=&quot;highlighter-rouge&quot;&gt;.sig&lt;/code&gt; files by first searching them for BusyBox using &lt;code class=&quot;highlighter-rouge&quot;&gt;grep busybox wm* -r&lt;/code&gt;. If grep finds the BusyBox in one of the files, the file system can be extracted with Binwalk, for example &lt;code class=&quot;highlighter-rouge&quot;&gt;binwalk -e wmɩɩ0_0ɯ0ɨ.pro.fw.sig&lt;/code&gt;. The next step was to figure out the encryption method. The binary could be reversed, but the binary includes a lot of functions to work through, so I chose to use a virtual environment to run BusyBox and inspect it from there. To get BusyBox running, I ran it in an Arm chroot with Qemu. I installed qemu-user-static with &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install qemu-user-static then told it to build the chroot with sudo qemu-debootstrap --arch armhf jessie eabi-chroot&lt;/code&gt;. That installs and sets up an environment in a folder called &lt;code class=&quot;highlighter-rouge&quot;&gt;eabi-chroot&lt;/code&gt;. To get BusyBox running, I copied the BusyBox binary into the root of the &lt;code class=&quot;highlighter-rouge&quot;&gt;eadi-chroot&lt;/code&gt;. I also created a folder &lt;code class=&quot;highlighter-rouge&quot;&gt;ftp&lt;/code&gt; in the root as well, as BusyBox looks for this folder when starting the ftp environment. Inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;ftp&lt;/code&gt; folder, I placed a &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt; file used to test if ftp was working or not. BusyBox can then be launched with &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chroot eabi-chroot&lt;/code&gt;, then running &lt;code class=&quot;highlighter-rouge&quot;&gt;./busybox tcpsvd -vE 0.0.0.0 21 ./busybox ftpd -wv /tmp/&lt;/code&gt; to get the ftp server running.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_2.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 2. BusyBox FTP server running in Qemu. I then connected to the ftp server with the username &lt;code class=&quot;highlighter-rouge&quot;&gt;nouser&lt;/code&gt; and requested a file.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_3.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 2. FTP server successfully transferring files. &lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;radare2&lt;/code&gt; were attached to the process and &lt;code class=&quot;highlighter-rouge&quot;&gt;Ghidra&lt;/code&gt; was used for static analysis to locate the file transfer functions. Now that a file has been requested, I used the debuggers and &lt;code class=&quot;highlighter-rouge&quot;&gt;Ghidra&lt;/code&gt; to determine that the key wasplaced into memory. I used several different tools to look at the process memory for possible encryption keys or signatures, finally landing on &lt;a href=&quot;https://github.com/mmozeiko/aes-finder&quot;&gt;AES finder&lt;/a&gt; and discovering it used AES encryption. The tool revealed DJI used an AES-128 bit encryption and it pulled the key from memory, but it did not find the IV. Now that the encryption and the AES key is known, it is significantly easier to look for specific encryption functions in the binary by searching for the AES key. Following the function where the AES key is used, it leads to the IV and later the packing used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_4.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 4. AES IV located inside the BusyBox binary shown with &lt;code class=&quot;highlighter-rouge&quot;&gt;Ghidra&lt;/code&gt;. Knowing the AES key, the IV, and the packing, it is trivial to write asmall Python script to decrypt the files:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Created by Andrew Clark on 7/30/19
import sys, os 
from Crypto.Cipher import AES
from pkcs7 import PKCS7Encoder 
key = &quot;YP1Nag7ZR&amp;amp;Dj\x00\x00\x00\x00&quot; 
iv  = &quot;0123456789abcdef&quot; 
aes = AES.new(key, AES.MODE_CBC, iv)

if len(sys.argv) &amp;lt; 2:
    print &quot;Usage: decrypt.py FILE&quot;
    exit()
 else:
    if os.path.isfile(sys.argv[1]):                 
        print &quot;Opening and decrypting file...&quot;                 encryptedFile = open(sys.argv[1], 'rb').read()            decryptedFile = aes.decrypt(encryptedFile)
        encoding = PKCS7Encoder()
        decodedFile = encoding.decode(decryptedFile)
        outputFile = open(sys.argv[1] + &quot;.decrypted&quot;, 'w+')
        outputFile.write(decodedFile)
        outputFile.close()
        print &quot;Done. \nDecrypted file was written to %s&quot; % sys.argv[1] + &quot;.decrypted&quot;
    else:
        print &quot;Could not open file.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The IV did not change across drone versions, but the AES key did twice, the most recent versions all have the same key though. Knowing
the IV, it is now easiest to get the AES key for future versions by checking in a disassembler if the IV string is present and locating the AES
key in that same function. Or simply searching for the following bytes will produce the AES function: &lt;code class=&quot;highlighter-rouge&quot;&gt;06 30 9f e7 03 30 90 e7 02 00 53 e3 09 00 00 0a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the end, the log files look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-25/Pic_5.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The process outline for decrypting the drone data was as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Obtain drone filesystem.
    &lt;ul&gt;
      &lt;li&gt;Done by searching for open source DJI Drone firmware downloading tools.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Determine how to extract drone firmware.
    &lt;ul&gt;
      &lt;li&gt;Completed by examining headers and using binwalk to extract the filesystem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Determine what part of the firmware deals with log files.
    &lt;ul&gt;
      &lt;li&gt;Firmware was examined to determine what software ran on the drone.
        &lt;ul&gt;
          &lt;li&gt;After BusyBox was determined to be running on the drone, it’s source code was analyzed to find file transfer and logging functions.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Attempt to run drone software in a visualized environment for debugging.
    &lt;ul&gt;
      &lt;li&gt;I researched QEMU and visualizing embedded systems, trying various configurations to get BusyBox running.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Debug BusyBox to determine encryption.
    &lt;ul&gt;
      &lt;li&gt;GDB and Radare were used to debug and determine when the data was encrypted.
        &lt;ul&gt;
          &lt;li&gt;Ghidra was used to disassemble the BusyBox binary and locate the file transfer functions with help from the debuggers.
            &lt;ul&gt;
              &lt;li&gt;It was discovered that the key was put into memory, so open source tools were tested against the BusyBox process memory tp pull a key from memory.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Write a script to decrypt logs.
    &lt;ul&gt;
      &lt;li&gt;Knowing the key, the encryption could be determined and Ghidra was used to find the encryption functions to obtain the IV and packing type.
        &lt;ul&gt;
          &lt;li&gt;A Python script was written with open source libraries to decrypt the files with the appropriate key, IV, encryption, and packing.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Allow for easier obtaining of keys for future drone versions.
    &lt;ul&gt;
      &lt;li&gt;A unique byte pattern in the encryption function referencing the key and IV was found allowing for disassembler to search for the pattern and immediately obtain references to the key and IV.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Analyzing MacOS Malware that Executes a Payload in Memory</title>
   <link href="/2020/01/22/mac-malware/"/>
   <updated>2020-01-22T00:00:00-05:00</updated>
   <id>https://starwarsfan2099.github.io/2020/01/22/mac-malware</id>
   <content type="html">&lt;p&gt;This post was inspired by Dinesh Devadoss’s &lt;a href=&quot;https://twitter.com/dineshdina04/status/1201834142704394242?s=20&quot;&gt;post on twitter&lt;/a&gt; about a piece of MacOS malware from the Lazarus group that loads a Mach-O into memory and executes it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_1.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Loading a Mach-O into memory for execution peeked my interest and I wanted to know how it worked. So I obtained a sample of the malware from the website spreading it. The malware was obtained from &lt;code class=&quot;highlighter-rouge&quot;&gt;https://unioncrypto.vip/&lt;/code&gt; , which is now down but previously resolved to &lt;code class=&quot;highlighter-rouge&quot;&gt;104.168.167.16&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I first searched the MD5 hash of the file (&lt;code class=&quot;highlighter-rouge&quot;&gt;6588d262529dc372c400bef8478c2eec&lt;/code&gt;) on VirusTotal. It had been uploaded and most of the major AV companies flag the malware.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_2.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using VirusTotal, we can get a lot of preliminary information about the malware. Some interesting information is files opened, written, and dropped.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_3.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_4.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_5.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To inspect the file locally, first I mounted the disk image with &lt;code class=&quot;highlighter-rouge&quot;&gt;hdiutil attach UnionCryptoTrader.dmg&lt;/code&gt;. It contained a single file named &lt;code class=&quot;highlighter-rouge&quot;&gt;UnionCryptoTrader.pkg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_6.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The package file was not singed, meaning MacOS would prompt the user with a warning before they could install the package.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_7.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Examine the package file, I extracted the app installed, &lt;code class=&quot;highlighter-rouge&quot;&gt;UnionCryptoTrader.app&lt;/code&gt; and any scripts within the package with resulted in a &lt;code class=&quot;highlighter-rouge&quot;&gt;postinstall&lt;/code&gt; script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_8.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before I jumped into the app executable, I wanted to see what the &lt;code class=&quot;highlighter-rouge&quot;&gt;postinstall&lt;/code&gt; script did.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_9.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In line 2, script moves a hidden plist file (&lt;code class=&quot;highlighter-rouge&quot;&gt;.vip.unioncrypto.plist&lt;/code&gt;) from the app’s resources to the Launch Daemons directory, probably to give the app persistence across reboots or when a user logs out. The script then sets the plist to be owned by root in line 4. Since it does this, the user will also have to enter the root password to install this on their machine, hopefully adding some doubt to unsuspecting users. Line 6 creates a directory, and line 8 moves a hidden executable (&lt;code class=&quot;highlighter-rouge&quot;&gt;.unioncryptoupdater&lt;/code&gt;) from the resources into the Library path. Line 10 sets executable permissions and line 12 executes the binary. Once this script runs successfully, &lt;code class=&quot;highlighter-rouge&quot;&gt;unioncryptoupdater&lt;/code&gt; is running and is persistently installed to the machine.&lt;/p&gt;

&lt;p&gt;Going to the app’s package contents, then using Command + Shift + . in finder, I could easily see the hidden files. Opening up the plist file shows &lt;code class=&quot;highlighter-rouge&quot;&gt;RunAtLoad&lt;/code&gt; set to true, further confirming persistence.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_10.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The file is a standard Mach-O 64 bit binary with ad-hoc code signing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_11.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next, I looked at the strings in the binary.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_easy_perform() failed: %s
Response &amp;lt;
&amp;gt; thrown.
AES_CYPHER_128 encrypt test case:
AES_CYPHER_128 decrypt test case:
AES_CYPHER_192 encrypt test case:
AES_CYPHER_192 decrypt test case:
AES_CYPHER_256 encrypt test case:
AES_CYPHER_256 decrypt test case:
Input:
IOPlatformExpertDevice
IOPlatformSerialNumber
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
ProductBuildVersion
Mac OS X %s (%s)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
/tmp/updater
%s %s
NO_ID
%s%s
12GWAPCT1F0I1S14
auth_timestamp
auth_signature
check
https://unioncrypto.vip/update
done
/bin/rcp
Could not create image.
core
Could not link image.
Could not find ec.
Could not resolve symbol: _sym[25] == 0x4d6d6f72.
Could not resolve symbol: _sym[4] == 0x4d6b6e69.
c|w{
9JLX
~=d]
lpHP
cU!}
&quot;3DUfw
0123456789abcdef
dictionaryWithContentsOfFile:
objectForKey:
UTF8String
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first thing I noted was &lt;code class=&quot;highlighter-rouge&quot;&gt;curl_easy_perform() failed: %s&lt;/code&gt;. The binary includes &lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl&lt;/code&gt; so it probably has some network functionality. Other things to note are&lt;code class=&quot;highlighter-rouge&quot;&gt; IOPlatformExpertDevice&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IOPlatformSerialNumber&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/CoreServices/SystemVersion.plist&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductVersion&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductBuildVersion&lt;/code&gt;. The malware appears to gather a lot of system information.&lt;/p&gt;

&lt;p&gt;I then decided it was time to open the binary in a disassembler. The binary begins with the expected Mach-O signature &lt;code class=&quot;highlighter-rouge&quot;&gt;FE ED FA CF&lt;/code&gt;. It does some setup stuff, then proceeds to a function appropriately named &lt;code class=&quot;highlighter-rouge&quot;&gt;onRun&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_12.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The function proceeds to setup a class named &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque&lt;/code&gt;. It contains functions such as &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque::get&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque::post&lt;/code&gt;, and includes references to &lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl&lt;/code&gt;, so it’s safe to assume this is the networking class for the malware. The function then calls another function named &lt;code class=&quot;highlighter-rouge&quot;&gt;getDeviceSerial&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x1000051f2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_13.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This code initializes IOKit, calls &lt;code class=&quot;highlighter-rouge&quot;&gt;IORegistryEntryCreateCFProperty&lt;/code&gt; with the &lt;code class=&quot;highlighter-rouge&quot;&gt;IOPlatformSerialNumber&lt;/code&gt; key, converts it to C string buffer with &lt;code class=&quot;highlighter-rouge&quot;&gt;CFStringGetCString&lt;/code&gt;, and returns the serial number. The &lt;code class=&quot;highlighter-rouge&quot;&gt;onRun&lt;/code&gt; function continues and calls a function named &lt;code class=&quot;highlighter-rouge&quot;&gt;getOSVersion&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10000522a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_14.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This code reads the file &lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/CoreServices/SystemVersion.plist&lt;/code&gt; and reads the &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductName&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductUserVisibleVersion&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ProductBuildVersion&lt;/code&gt; keys from the plist file and begins to build a string. Later in &lt;code class=&quot;highlighter-rouge&quot;&gt;onRun&lt;/code&gt;, the current time is added to the string and the hardcoded values &lt;code class=&quot;highlighter-rouge&quot;&gt;\x31\x32\x47\x57\x41\x50\x43\x54\x31\x46\x30\x49\x31\x53\x31\x34&lt;/code&gt; are appended to it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_15.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next the malware invokes &lt;code class=&quot;highlighter-rouge&quot;&gt;Barbeque:post&lt;/code&gt; which uses &lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl&lt;/code&gt; to send the string to &lt;code class=&quot;highlighter-rouge&quot;&gt;https://unioncrypto.vip/update&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_16.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The malware then awaits a response. If the response is &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; the function jumps to &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10000583f&lt;/code&gt; which is a short function that calls &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep()&lt;/code&gt; for 10 minutes. However, if the server doesn’t return &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, it base64 decodes the response and calls &lt;code class=&quot;highlighter-rouge&quot;&gt;processUpdate()&lt;/code&gt; as seen in the following disassembly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_17.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And this is the first part of &lt;code class=&quot;highlighter-rouge&quot;&gt;processUpdate()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_18.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are some checks to make sure the string is valid and then the string is AES decrypted as seen at the function call at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x100004c85&lt;/code&gt;. The malware then jumps to &lt;code class=&quot;highlighter-rouge&quot;&gt;_load_from_memory()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_19.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This function first maps some memory with mmap &lt;code class=&quot;highlighter-rouge&quot;&gt;mmap(0, arg2, 7, 0x1001, 0xFFFFFFFF, 0);&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0x1001&lt;/code&gt; being &lt;code class=&quot;highlighter-rouge&quot;&gt;PROT_READ | PROT_WRITE | PROT_EXEC&lt;/code&gt;. It then copies the decrypted payload into that memory and calls &lt;code class=&quot;highlighter-rouge&quot;&gt;_memory_exec2&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x100006e2b&lt;/code&gt;. This function is a bit more complicated.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_20.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essentially, this calls the Apple API method &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCreateObjectFileImageFromMemory()&lt;/code&gt; and creates an object file image from a memory buffer, more specifically, the payload placed in memory. &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLinkModule&lt;/code&gt; is then called to link it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_21.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next, it calls a function named &lt;code class=&quot;highlighter-rouge&quot;&gt;find_macho&lt;/code&gt; which does as the name implies and searches the memory mapping for the mach magic number &lt;code class=&quot;highlighter-rouge&quot;&gt;0xfeedfacf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_22.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It then searches the payload for a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80000028&lt;/code&gt;. This value is the Mach-O load command, so the payload decrypted from the server is a Mach-O file. The load command, &lt;code class=&quot;highlighter-rouge&quot;&gt;LC_MAIN&lt;/code&gt;, contains various values as well as the entry point of the Mach-O binary.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_23.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code finds the entry point at offset &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8&lt;/code&gt;, sets up some arguments (all &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;’s), and jumps to the entry point of the Mach-O in memory.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_24.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, to execute a payload straight from memory, the malware loads a download Mach-O file into memory using &lt;code class=&quot;highlighter-rouge&quot;&gt;mmap()&lt;/code&gt; with protections &lt;code class=&quot;highlighter-rouge&quot;&gt;PROT_READ | PROT_WRITE | PROT_EXEC&lt;/code&gt;, then it uses &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCreateObjectFileImageFromMemory()&lt;/code&gt; to create an object image using the Mach-O in memory, next it uses &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLinkModule&lt;/code&gt; to link the the module in memory, filling that it searches for the Mach-O magic number &lt;code class=&quot;highlighter-rouge&quot;&gt;0xfeedfacf&lt;/code&gt; and then finds the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;LC_MAIN&lt;/code&gt; - the Mach-O load command, then at offset &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8&lt;/code&gt; it finds the entry pint to the Mach-O, sets up argument for the entry point, and jumps to it straight in memory.&lt;/p&gt;

&lt;p&gt;And last but not least:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://starwarsfan2099.github.io/public/2020-1-22/Pic_25.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the function &lt;code class=&quot;highlighter-rouge&quot;&gt;_load_from_memory()&lt;/code&gt; fails and returns &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, it just copies the Mach-O to &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/updater&lt;/code&gt; and executes it with &lt;code class=&quot;highlighter-rouge&quot;&gt;system()&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
